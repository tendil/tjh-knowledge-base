<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=DESCRIPTION><meta name=author content="Dmitry Meita"><link rel=canonical href=https://tendil.github.io/tjh-knowledge-base/interview_questions/javascript.html><link rel=prev href=git.html><link rel=next href=java.html><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.5.3, mkdocs-material-9.3.1"><title>JavaScript - TJHelpers Knowledge Base</title><link rel=stylesheet href=../assets/stylesheets/main.046329b4.min.css><link rel=stylesheet href=../assets/stylesheets/palette.85d0ee34.min.css><script src=https://unpkg.com/iframe-worker/shim></script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../stylesheets/extra.css><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=custom data-md-color-accent=deep-purple> <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#3-javascript class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=.. title="TJHelpers Knowledge Base" class="md-header__button md-logo" aria-label="TJHelpers Knowledge Base" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> TJHelpers Knowledge Base </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> JavaScript </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=custom data-md-color-accent=deep-purple aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=teal data-md-color-accent=lime aria-label="Switch to light mode" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"/></svg> </label> </form> <div class=md-header__option> <div class=md-select> <button class="md-header__button md-icon" aria-label="Select language"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg> </button> <div class=md-select__inner> <ul class=md-select__list> <li class=md-select__item> <a href=/en/ hreflang=en class=md-select__link> English </a> </li> <li class=md-select__item> <a href=/uk/ hreflang=uk class=md-select__link> Ukrainian </a> </li> </ul> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/tendil/tjh-knowledge-base title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> tendil/tjh-knowledge-base </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="TJHelpers Knowledge Base" class="md-nav__button md-logo" aria-label="TJHelpers Knowledge Base" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> TJHelpers Knowledge Base </label> <div class=md-nav__source> <a href=https://github.com/tendil/tjh-knowledge-base title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> tendil/tjh-knowledge-base </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../blog/blog_index.html class=md-nav__link> <span class=md-ellipsis> Blog </span> </a> </li> <li class=md-nav__item> <a href=../gitflow/GITFLOW.html class=md-nav__link> <span class=md-ellipsis> GIT Flow </span> </a> </li> <li class=md-nav__item> <a href=../telegram_bot/tjh_parser_bot.html class=md-nav__link> <span class=md-ellipsis> TJH Parser Bot </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> Interview Questions & Answers </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=true> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Interview Questions & Answers </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=python.html class=md-nav__link> <span class=md-ellipsis> Python </span> </a> </li> <li class=md-nav__item> <a href=git.html class=md-nav__link> <span class=md-ellipsis> GIT </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> JavaScript </span> <span class="md-nav__icon md-icon"></span> </label> <a href=javascript.html class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> JavaScript </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#3-javascript class=md-nav__link> 3. Запитання для співбесіди на тему JavaScript </a> </li> <li class=md-nav__item> <a href=#-javascript class=md-nav__link> Відповіді - 'JavaScript' </a> <nav class=md-nav aria-label="Відповіді - 'JavaScript'"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1-javascript class=md-nav__link> 1. Які існують способи створення обєктів у JavaScript </a> </li> <li class=md-nav__item> <a href=#2 class=md-nav__link> 2. Що таке ланцюг прототипів </a> </li> <li class=md-nav__item> <a href=#3-call-apply-bind class=md-nav__link> 3. В чому різниця між методами Call, Apply та Bind </a> </li> <li class=md-nav__item> <a href=#4-json class=md-nav__link> 4. Що таке JSON та його загальні операції </a> </li> <li class=md-nav__item> <a href=#5-slice class=md-nav__link> 5. Яка мета методу slice для масиву </a> </li> <li class=md-nav__item> <a href=#6-splice class=md-nav__link> 6. Яка мета методу splice для масиву </a> </li> <li class=md-nav__item> <a href=#7-slice-splice class=md-nav__link> 7. В чому різниця між slice та splice </a> </li> <li class=md-nav__item> <a href=#8-map class=md-nav__link> 8. Як порівняти Об'єкт із Map </a> </li> <li class=md-nav__item> <a href=#9 class=md-nav__link> 9. В чому різниця між операторами == та === </a> </li> <li class=md-nav__item> <a href=#10- class=md-nav__link> 10. Що таке лямбда- або стрілкові функції </a> </li> <li class=md-nav__item> <a href=#11 class=md-nav__link> 11. Що таке функція першого класу </a> </li> <li class=md-nav__item> <a href=#12 class=md-nav__link> 12. Що таке функція першого порядку </a> </li> <li class=md-nav__item> <a href=#13 class=md-nav__link> 13. Що таке функція вищого порядку </a> </li> <li class=md-nav__item> <a href=#14 class=md-nav__link> 14. Що таке унарна функція </a> </li> <li class=md-nav__item> <a href=#15 class=md-nav__link> 15. Що таке функція каррінг </a> </li> <li class=md-nav__item> <a href=#16 class=md-nav__link> 16. Що таке чиста функція </a> </li> <li class=md-nav__item> <a href=#17-let class=md-nav__link> 17. Яка мета ключового слова let </a> </li> <li class=md-nav__item> <a href=#18-let-var class=md-nav__link> 18. В чому різниця між let та var </a> </li> <li class=md-nav__item> <a href=#19-let class=md-nav__link> 19. Яка причина вибору назви let як ключового слова </a> </li> <li class=md-nav__item> <a href=#20-switch class=md-nav__link> 20. Як перевизначити змінні в switch блоку без помилки </a> </li> <li class=md-nav__item> <a href=#21 class=md-nav__link> 21. Що таке Тимчасова мертва зона </a> </li> <li class=md-nav__item> <a href=#22-iife class=md-nav__link> 22. Що таке Негайно Викликані Функціональні Вирази (IIFE) </a> </li> <li class=md-nav__item> <a href=#23-url-javascript class=md-nav__link> 23. Як декодувати або закодувати URL в JavaScript? </a> </li> <li class=md-nav__item> <a href=#24 class=md-nav__link> 24. Що таке мемоізація </a> </li> <li class=md-nav__item> <a href=#25 class=md-nav__link> 25.Що таке Хойстінг </a> </li> <li class=md-nav__item> <a href=#26-es6 class=md-nav__link> 26. Що таке класи в ES6 </a> </li> <li class=md-nav__item> <a href=#27 class=md-nav__link> 27. Що таке замикання </a> </li> <li class=md-nav__item> <a href=#28 class=md-nav__link> 28. Що таке модулі </a> </li> <li class=md-nav__item> <a href=#29 class=md-nav__link> 29. Чому вам потрібні модулі </a> </li> <li class=md-nav__item> <a href=#30-javascript class=md-nav__link> 30. Що таке область видимості в JavaScript </a> </li> <li class=md-nav__item> <a href=#31-service-worker class=md-nav__link> 31. Що таке сервісний працівник (service worker) </a> </li> <li class=md-nav__item> <a href=#32-dom-service-worker class=md-nav__link> 32. Як ви змінюєте DOM, використовуючи сервісний працівник (service worker) </a> </li> <li class=md-nav__item> <a href=#33-service-worker class=md-nav__link> 33. Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker) </a> </li> <li class=md-nav__item> <a href=#34-indexeddb class=md-nav__link> 34. Що таке IndexedDB </a> </li> <li class=md-nav__item> <a href=#35-web-storage class=md-nav__link> 35. Що таке веб-сховище (web storage) </a> </li> <li class=md-nav__item> <a href=#36-post-message class=md-nav__link> 36. Що таке пост-повідомлення (post message) </a> </li> <li class=md-nav__item> <a href=#37-cookie class=md-nav__link> 37. Що таке кука (cookie) </a> </li> <li class=md-nav__item> <a href=#38-cookie class=md-nav__link> 38. Чому вам потрібна кука (cookie) </a> </li> <li class=md-nav__item> <a href=#39-cookie class=md-nav__link> 39. Які параметри куки (cookie) </a> </li> <li class=md-nav__item> <a href=#40-cookie class=md-nav__link> 40. Як видаляти куку (cookie) </a> </li> <li class=md-nav__item> <a href=#41-local-storage-session-storage class=md-nav__link> 41. Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage) </a> </li> <li class=md-nav__item> <a href=#42-localstorage-sessionstorage class=md-nav__link> 42. Яка основна різниця між localStorage та sessionStorage </a> </li> <li class=md-nav__item> <a href=#43-web-storage class=md-nav__link> 43. Як отримати доступ до веб-сховища (web storage) </a> </li> <li class=md-nav__item> <a href=#44-session-storage class=md-nav__link> 44. Які методи доступні для сеансового сховища (session storage) </a> </li> <li class=md-nav__item> <a href=#45-storage-event-event-handler class=md-nav__link> 45. Що таке подія сховища (storage event) та його обробник події (event handler) </a> </li> <li class=md-nav__item> <a href=#46-web-storage class=md-nav__link> 46. Чому вам потрібне веб-сховище (web storage) </a> </li> <li class=md-nav__item> <a href=#47-browser-support class=md-nav__link> 47. Як перевірити підтримку веб-сховища браузером (browser support) </a> </li> <li class=md-nav__item> <a href=#48-browser-support class=md-nav__link> 48. Як перевірити підтримку веб-працівників браузером (browser support) </a> </li> <li class=md-nav__item> <a href=#49-web-worker class=md-nav__link> 49. Надайте приклад веб-працівника (web worker) </a> </li> <li class=md-nav__item> <a href=#50-dom class=md-nav__link> 50. Які обмеження веб-працівників на DOM </a> </li> <li class=md-nav__item> <a href=#51-promise class=md-nav__link> 51. Що таке обіцянка (promise) </a> </li> <li class=md-nav__item> <a href=#52-promise class=md-nav__link> 52. Чому вам потрібна обіцянка (promise) </a> </li> <li class=md-nav__item> <a href=#53-promise class=md-nav__link> 53. Які три стани у обіцянки (promise) </a> </li> <li class=md-nav__item> <a href=#54-callback-function class=md-nav__link> 54. Що таке зворотний виклик (callback function) </a> </li> <li class=md-nav__item> <a href=#55-callbacks class=md-nav__link> 55. Чому нам потрібні зворотні виклики (callbacks) </a> </li> <li class=md-nav__item> <a href=#56-callback-hell class=md-nav__link> 56. Що таке "інферно зворотніх викликів" (callback hell) </a> </li> <li class=md-nav__item> <a href=#57-server-sent-events class=md-nav__link> 57. Що таке події, відправлені з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#58-server-sent-events class=md-nav__link> 58. Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#59-server-sent-events class=md-nav__link> 59. Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#60-server-sent-events class=md-nav__link> 60. Які події доступні для подій, відправлених з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#61-promise class=md-nav__link> 61. Які основні правила обіцянок (promise) </a> </li> <li class=md-nav__item> <a href=#62-callback-in-callback class=md-nav__link> 62. Що таке зворотній виклик у зворотньому виклику (callback in callback) </a> </li> <li class=md-nav__item> <a href=#63-promise-chaining class=md-nav__link> 63. Що таке ланцюг обіцянок (promise chaining) </a> </li> <li class=md-nav__item> <a href=#64-promiseall class=md-nav__link> 64. Що таке promise.all </a> </li> <li class=md-nav__item> <a href=#65-race-promise class=md-nav__link> 65. Яка мета методу race у обіцянок (promise) </a> </li> <li class=md-nav__item> <a href=#66-javascript-strict-mode class=md-nav__link> 66. Що таке строгий режим у JavaScript (strict mode) </a> </li> <li class=md-nav__item> <a href=#67-strict-mode class=md-nav__link> 67. Чому вам потрібен строгий режим (strict mode) </a> </li> <li class=md-nav__item> <a href=#68-strict-mode class=md-nav__link> 68. Як ви оголошуєте строгий режим (strict mode) </a> </li> <li class=md-nav__item> <a href=#69-double-exclamation class=md-nav__link> 69. Яка мета подвійного оклику (!!) (double exclamation) </a> </li> <li class=md-nav__item> <a href=#70-delete class=md-nav__link> 70. Яка мета оператора delete </a> </li> <li class=md-nav__item> <a href=#71-typeof class=md-nav__link> 71. Який оператор typeof </a> </li> <li class=md-nav__item> <a href=#72-undefined class=md-nav__link> 72. Що таке властивість undefined </a> </li> <li class=md-nav__item> <a href=#73-null class=md-nav__link> 73. Що таке значення null </a> </li> <li class=md-nav__item> <a href=#74-null-undefined class=md-nav__link> 74. Яка різниця між значенням null та undefined </a> </li> <li class=md-nav__item> <a href=#75-eval class=md-nav__link> 75. Що таке функція eval </a> </li> <li class=md-nav__item> <a href=#76-window-document class=md-nav__link> 76. Яка різниця між об'єктом window та document </a> </li> <li class=md-nav__item> <a href=#77-javascript class=md-nav__link> 77. Як ви отримуєте доступ до історії у JavaScript </a> </li> <li class=md-nav__item> <a href=#78-caps-lock class=md-nav__link> 78. Як ви визначаєте, чи включена клавіша Caps Lock, чи ні </a> </li> <li class=md-nav__item> <a href=#79-isnan class=md-nav__link> 79. Що таке функція isNaN </a> </li> <li class=md-nav__item> <a href=#80-undefined class=md-nav__link> 80. Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined </a> </li> <li class=md-nav__item> <a href=#81 class=md-nav__link> 81. Що таке глобальні змінні </a> </li> <li class=md-nav__item> <a href=#82 class=md-nav__link> 82. Які проблеми із глобальними змінними </a> </li> <li class=md-nav__item> <a href=#83-nan class=md-nav__link> 83. Що таке властивість NaN </a> </li> <li class=md-nav__item> <a href=#84-isfinite class=md-nav__link> 84. Яка мета функції isFinite </a> </li> <li class=md-nav__item> <a href=#85-event-flow class=md-nav__link> 85. Що таке потік подій (event flow) </a> </li> <li class=md-nav__item> <a href=#86-event-bubbling class=md-nav__link> 86. Що таке всплиття подій (event bubbling) </a> </li> <li class=md-nav__item> <a href=#87-event-capturing class=md-nav__link> 87. Що таке захоплення подій (event capturing) </a> </li> <li class=md-nav__item> <a href=#88-javascript class=md-nav__link> 88. Як ви відправляєте форму за допомогою JavaScript </a> </li> <li class=md-nav__item> <a href=#89 class=md-nav__link> 89. Як ви знаходите деталі операційної системи </a> </li> <li class=md-nav__item> <a href=#90-document-load-domcontentloaded class=md-nav__link> 90. Яка різниця між подіями document load та DOMContentLoaded </a> </li> <li class=md-nav__item> <a href=#91-native-host-user class=md-nav__link> 91. Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами </a> </li> <li class=md-nav__item> <a href=#92-javascript class=md-nav__link> 92. Які інструменти або техніки використовуються для відлагодження коду JavaScript </a> </li> <li class=md-nav__item> <a href=#93-promises-callbacks class=md-nav__link> 93. Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks) </a> </li> <li class=md-nav__item> <a href=#94-property class=md-nav__link> 94. Яка різниця між атрибутом та властивістю (property) </a> </li> <li class=md-nav__item> <a href=#95-same-origin-policy class=md-nav__link> 95. Що таке політика однакового походження (same-origin policy) </a> </li> <li class=md-nav__item> <a href=#96-void-0 class=md-nav__link> 96. Яка мета фрази void 0 </a> </li> <li class=md-nav__item> <a href=#97-javascript class=md-nav__link> 97. Чи є JavaScript компільованою чи інтерпретованою мовою </a> </li> <li class=md-nav__item> <a href=#98-javascript class=md-nav__link> 98. Чи є JavaScript чутливою до регістру мовою </a> </li> <li class=md-nav__item> <a href=#99-java-javascript class=md-nav__link> 99. Чи існує якась зв'язок між Java та JavaScript </a> </li> <li class=md-nav__item> <a href=#100-events class=md-nav__link> 100. Що таке події (events) </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=java.html class=md-nav__link> <span class=md-ellipsis> Java </span> </a> </li> <li class=md-nav__item> <a href=qa_manual_qa_automation.html class=md-nav__link> <span class=md-ellipsis> QA Manual & QA Automation </span> </a> </li> <li class=md-nav__item> <a href=typescript.html class=md-nav__link> <span class=md-ellipsis> TypeScript </span> </a> </li> <li class=md-nav__item> <a href=cicd.html class=md-nav__link> <span class=md-ellipsis> CI/CD </span> </a> </li> <li class=md-nav__item> <a href=basic_principle_of_programming.html class=md-nav__link> <span class=md-ellipsis> Основні принципи програмування </span> </a> </li> <li class=md-nav__item> <a href=database.html class=md-nav__link> <span class=md-ellipsis> Бази данних </span> </a> </li> <li class=md-nav__item> <a href=general_questions.html class=md-nav__link> <span class=md-ellipsis> Загальні питання </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#3-javascript class=md-nav__link> 3. Запитання для співбесіди на тему JavaScript </a> </li> <li class=md-nav__item> <a href=#-javascript class=md-nav__link> Відповіді - 'JavaScript' </a> <nav class=md-nav aria-label="Відповіді - 'JavaScript'"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1-javascript class=md-nav__link> 1. Які існують способи створення обєктів у JavaScript </a> </li> <li class=md-nav__item> <a href=#2 class=md-nav__link> 2. Що таке ланцюг прототипів </a> </li> <li class=md-nav__item> <a href=#3-call-apply-bind class=md-nav__link> 3. В чому різниця між методами Call, Apply та Bind </a> </li> <li class=md-nav__item> <a href=#4-json class=md-nav__link> 4. Що таке JSON та його загальні операції </a> </li> <li class=md-nav__item> <a href=#5-slice class=md-nav__link> 5. Яка мета методу slice для масиву </a> </li> <li class=md-nav__item> <a href=#6-splice class=md-nav__link> 6. Яка мета методу splice для масиву </a> </li> <li class=md-nav__item> <a href=#7-slice-splice class=md-nav__link> 7. В чому різниця між slice та splice </a> </li> <li class=md-nav__item> <a href=#8-map class=md-nav__link> 8. Як порівняти Об'єкт із Map </a> </li> <li class=md-nav__item> <a href=#9 class=md-nav__link> 9. В чому різниця між операторами == та === </a> </li> <li class=md-nav__item> <a href=#10- class=md-nav__link> 10. Що таке лямбда- або стрілкові функції </a> </li> <li class=md-nav__item> <a href=#11 class=md-nav__link> 11. Що таке функція першого класу </a> </li> <li class=md-nav__item> <a href=#12 class=md-nav__link> 12. Що таке функція першого порядку </a> </li> <li class=md-nav__item> <a href=#13 class=md-nav__link> 13. Що таке функція вищого порядку </a> </li> <li class=md-nav__item> <a href=#14 class=md-nav__link> 14. Що таке унарна функція </a> </li> <li class=md-nav__item> <a href=#15 class=md-nav__link> 15. Що таке функція каррінг </a> </li> <li class=md-nav__item> <a href=#16 class=md-nav__link> 16. Що таке чиста функція </a> </li> <li class=md-nav__item> <a href=#17-let class=md-nav__link> 17. Яка мета ключового слова let </a> </li> <li class=md-nav__item> <a href=#18-let-var class=md-nav__link> 18. В чому різниця між let та var </a> </li> <li class=md-nav__item> <a href=#19-let class=md-nav__link> 19. Яка причина вибору назви let як ключового слова </a> </li> <li class=md-nav__item> <a href=#20-switch class=md-nav__link> 20. Як перевизначити змінні в switch блоку без помилки </a> </li> <li class=md-nav__item> <a href=#21 class=md-nav__link> 21. Що таке Тимчасова мертва зона </a> </li> <li class=md-nav__item> <a href=#22-iife class=md-nav__link> 22. Що таке Негайно Викликані Функціональні Вирази (IIFE) </a> </li> <li class=md-nav__item> <a href=#23-url-javascript class=md-nav__link> 23. Як декодувати або закодувати URL в JavaScript? </a> </li> <li class=md-nav__item> <a href=#24 class=md-nav__link> 24. Що таке мемоізація </a> </li> <li class=md-nav__item> <a href=#25 class=md-nav__link> 25.Що таке Хойстінг </a> </li> <li class=md-nav__item> <a href=#26-es6 class=md-nav__link> 26. Що таке класи в ES6 </a> </li> <li class=md-nav__item> <a href=#27 class=md-nav__link> 27. Що таке замикання </a> </li> <li class=md-nav__item> <a href=#28 class=md-nav__link> 28. Що таке модулі </a> </li> <li class=md-nav__item> <a href=#29 class=md-nav__link> 29. Чому вам потрібні модулі </a> </li> <li class=md-nav__item> <a href=#30-javascript class=md-nav__link> 30. Що таке область видимості в JavaScript </a> </li> <li class=md-nav__item> <a href=#31-service-worker class=md-nav__link> 31. Що таке сервісний працівник (service worker) </a> </li> <li class=md-nav__item> <a href=#32-dom-service-worker class=md-nav__link> 32. Як ви змінюєте DOM, використовуючи сервісний працівник (service worker) </a> </li> <li class=md-nav__item> <a href=#33-service-worker class=md-nav__link> 33. Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker) </a> </li> <li class=md-nav__item> <a href=#34-indexeddb class=md-nav__link> 34. Що таке IndexedDB </a> </li> <li class=md-nav__item> <a href=#35-web-storage class=md-nav__link> 35. Що таке веб-сховище (web storage) </a> </li> <li class=md-nav__item> <a href=#36-post-message class=md-nav__link> 36. Що таке пост-повідомлення (post message) </a> </li> <li class=md-nav__item> <a href=#37-cookie class=md-nav__link> 37. Що таке кука (cookie) </a> </li> <li class=md-nav__item> <a href=#38-cookie class=md-nav__link> 38. Чому вам потрібна кука (cookie) </a> </li> <li class=md-nav__item> <a href=#39-cookie class=md-nav__link> 39. Які параметри куки (cookie) </a> </li> <li class=md-nav__item> <a href=#40-cookie class=md-nav__link> 40. Як видаляти куку (cookie) </a> </li> <li class=md-nav__item> <a href=#41-local-storage-session-storage class=md-nav__link> 41. Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage) </a> </li> <li class=md-nav__item> <a href=#42-localstorage-sessionstorage class=md-nav__link> 42. Яка основна різниця між localStorage та sessionStorage </a> </li> <li class=md-nav__item> <a href=#43-web-storage class=md-nav__link> 43. Як отримати доступ до веб-сховища (web storage) </a> </li> <li class=md-nav__item> <a href=#44-session-storage class=md-nav__link> 44. Які методи доступні для сеансового сховища (session storage) </a> </li> <li class=md-nav__item> <a href=#45-storage-event-event-handler class=md-nav__link> 45. Що таке подія сховища (storage event) та його обробник події (event handler) </a> </li> <li class=md-nav__item> <a href=#46-web-storage class=md-nav__link> 46. Чому вам потрібне веб-сховище (web storage) </a> </li> <li class=md-nav__item> <a href=#47-browser-support class=md-nav__link> 47. Як перевірити підтримку веб-сховища браузером (browser support) </a> </li> <li class=md-nav__item> <a href=#48-browser-support class=md-nav__link> 48. Як перевірити підтримку веб-працівників браузером (browser support) </a> </li> <li class=md-nav__item> <a href=#49-web-worker class=md-nav__link> 49. Надайте приклад веб-працівника (web worker) </a> </li> <li class=md-nav__item> <a href=#50-dom class=md-nav__link> 50. Які обмеження веб-працівників на DOM </a> </li> <li class=md-nav__item> <a href=#51-promise class=md-nav__link> 51. Що таке обіцянка (promise) </a> </li> <li class=md-nav__item> <a href=#52-promise class=md-nav__link> 52. Чому вам потрібна обіцянка (promise) </a> </li> <li class=md-nav__item> <a href=#53-promise class=md-nav__link> 53. Які три стани у обіцянки (promise) </a> </li> <li class=md-nav__item> <a href=#54-callback-function class=md-nav__link> 54. Що таке зворотний виклик (callback function) </a> </li> <li class=md-nav__item> <a href=#55-callbacks class=md-nav__link> 55. Чому нам потрібні зворотні виклики (callbacks) </a> </li> <li class=md-nav__item> <a href=#56-callback-hell class=md-nav__link> 56. Що таке "інферно зворотніх викликів" (callback hell) </a> </li> <li class=md-nav__item> <a href=#57-server-sent-events class=md-nav__link> 57. Що таке події, відправлені з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#58-server-sent-events class=md-nav__link> 58. Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#59-server-sent-events class=md-nav__link> 59. Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#60-server-sent-events class=md-nav__link> 60. Які події доступні для подій, відправлених з сервера (server-sent events) </a> </li> <li class=md-nav__item> <a href=#61-promise class=md-nav__link> 61. Які основні правила обіцянок (promise) </a> </li> <li class=md-nav__item> <a href=#62-callback-in-callback class=md-nav__link> 62. Що таке зворотній виклик у зворотньому виклику (callback in callback) </a> </li> <li class=md-nav__item> <a href=#63-promise-chaining class=md-nav__link> 63. Що таке ланцюг обіцянок (promise chaining) </a> </li> <li class=md-nav__item> <a href=#64-promiseall class=md-nav__link> 64. Що таке promise.all </a> </li> <li class=md-nav__item> <a href=#65-race-promise class=md-nav__link> 65. Яка мета методу race у обіцянок (promise) </a> </li> <li class=md-nav__item> <a href=#66-javascript-strict-mode class=md-nav__link> 66. Що таке строгий режим у JavaScript (strict mode) </a> </li> <li class=md-nav__item> <a href=#67-strict-mode class=md-nav__link> 67. Чому вам потрібен строгий режим (strict mode) </a> </li> <li class=md-nav__item> <a href=#68-strict-mode class=md-nav__link> 68. Як ви оголошуєте строгий режим (strict mode) </a> </li> <li class=md-nav__item> <a href=#69-double-exclamation class=md-nav__link> 69. Яка мета подвійного оклику (!!) (double exclamation) </a> </li> <li class=md-nav__item> <a href=#70-delete class=md-nav__link> 70. Яка мета оператора delete </a> </li> <li class=md-nav__item> <a href=#71-typeof class=md-nav__link> 71. Який оператор typeof </a> </li> <li class=md-nav__item> <a href=#72-undefined class=md-nav__link> 72. Що таке властивість undefined </a> </li> <li class=md-nav__item> <a href=#73-null class=md-nav__link> 73. Що таке значення null </a> </li> <li class=md-nav__item> <a href=#74-null-undefined class=md-nav__link> 74. Яка різниця між значенням null та undefined </a> </li> <li class=md-nav__item> <a href=#75-eval class=md-nav__link> 75. Що таке функція eval </a> </li> <li class=md-nav__item> <a href=#76-window-document class=md-nav__link> 76. Яка різниця між об'єктом window та document </a> </li> <li class=md-nav__item> <a href=#77-javascript class=md-nav__link> 77. Як ви отримуєте доступ до історії у JavaScript </a> </li> <li class=md-nav__item> <a href=#78-caps-lock class=md-nav__link> 78. Як ви визначаєте, чи включена клавіша Caps Lock, чи ні </a> </li> <li class=md-nav__item> <a href=#79-isnan class=md-nav__link> 79. Що таке функція isNaN </a> </li> <li class=md-nav__item> <a href=#80-undefined class=md-nav__link> 80. Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined </a> </li> <li class=md-nav__item> <a href=#81 class=md-nav__link> 81. Що таке глобальні змінні </a> </li> <li class=md-nav__item> <a href=#82 class=md-nav__link> 82. Які проблеми із глобальними змінними </a> </li> <li class=md-nav__item> <a href=#83-nan class=md-nav__link> 83. Що таке властивість NaN </a> </li> <li class=md-nav__item> <a href=#84-isfinite class=md-nav__link> 84. Яка мета функції isFinite </a> </li> <li class=md-nav__item> <a href=#85-event-flow class=md-nav__link> 85. Що таке потік подій (event flow) </a> </li> <li class=md-nav__item> <a href=#86-event-bubbling class=md-nav__link> 86. Що таке всплиття подій (event bubbling) </a> </li> <li class=md-nav__item> <a href=#87-event-capturing class=md-nav__link> 87. Що таке захоплення подій (event capturing) </a> </li> <li class=md-nav__item> <a href=#88-javascript class=md-nav__link> 88. Як ви відправляєте форму за допомогою JavaScript </a> </li> <li class=md-nav__item> <a href=#89 class=md-nav__link> 89. Як ви знаходите деталі операційної системи </a> </li> <li class=md-nav__item> <a href=#90-document-load-domcontentloaded class=md-nav__link> 90. Яка різниця між подіями document load та DOMContentLoaded </a> </li> <li class=md-nav__item> <a href=#91-native-host-user class=md-nav__link> 91. Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами </a> </li> <li class=md-nav__item> <a href=#92-javascript class=md-nav__link> 92. Які інструменти або техніки використовуються для відлагодження коду JavaScript </a> </li> <li class=md-nav__item> <a href=#93-promises-callbacks class=md-nav__link> 93. Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks) </a> </li> <li class=md-nav__item> <a href=#94-property class=md-nav__link> 94. Яка різниця між атрибутом та властивістю (property) </a> </li> <li class=md-nav__item> <a href=#95-same-origin-policy class=md-nav__link> 95. Що таке політика однакового походження (same-origin policy) </a> </li> <li class=md-nav__item> <a href=#96-void-0 class=md-nav__link> 96. Яка мета фрази void 0 </a> </li> <li class=md-nav__item> <a href=#97-javascript class=md-nav__link> 97. Чи є JavaScript компільованою чи інтерпретованою мовою </a> </li> <li class=md-nav__item> <a href=#98-javascript class=md-nav__link> 98. Чи є JavaScript чутливою до регістру мовою </a> </li> <li class=md-nav__item> <a href=#99-java-javascript class=md-nav__link> 99. Чи існує якась зв'язок між Java та JavaScript </a> </li> <li class=md-nav__item> <a href=#100-events class=md-nav__link> 100. Що таке події (events) </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/tendil/tjh-knowledge-base/edit/main/docs/interview_questions/javascript.md title="Edit this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4v-2m10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1 2.1 2.1Z"/></svg> </a> <a href=https://github.com/tendil/tjh-knowledge-base/raw/main/docs/interview_questions/javascript.md title="View source of this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.15 8.15 0 0 1-1.23-2Z"/></svg> </a> <h2 id=3-javascript><strong>3. Запитання для співбесіди на тему JavaScript</strong><a class=headerlink href=#3-javascript title="Permanent link">&para;</a></h2> <hr> <table> <thead> <tr> <th>№</th> <th>Питання</th> </tr> </thead> <tbody> <tr> <td>1</td> <td><a href=#1-javascript>Які існують способи створення об'єктів у JavaScript</a></td> </tr> <tr> <td>2</td> <td><a href=#2>Що таке ланцюг прототипів</a></td> </tr> <tr> <td>3</td> <td><a href=#3-call-apply-bind>В чому різниця між методами Call, Apply та Bind</a></td> </tr> <tr> <td>4</td> <td><a href=#4-json>Що таке JSON та його загальні операції</a></td> </tr> <tr> <td>5</td> <td><a href=#5-slice>Яка мета методу slice для масиву</a></td> </tr> <tr> <td>6</td> <td><a href=#6-splice>Яка мета методу splice для масиву</a></td> </tr> <tr> <td>7</td> <td><a href=#7-slice-splice>В чому різниця між slice та splice</a></td> </tr> <tr> <td>8</td> <td><a href=#8-map>Як порівняти Об'єкт із Map</a></td> </tr> <tr> <td>9</td> <td><a href=#9>В чому різниця між операторами == та ===</a></td> </tr> <tr> <td>10</td> <td><a href=#10->Що таке лямбда- або стрілкові функції</a></td> </tr> <tr> <td>11</td> <td><a href=#11>Що таке функція першого класу</a></td> </tr> <tr> <td>12</td> <td><a href=#12>Що таке функція першого порядку</a></td> </tr> <tr> <td>13</td> <td><a href=#13>Що таке функція вищого порядку</a></td> </tr> <tr> <td>14</td> <td><a href=#14>Що таке унарна функція</a></td> </tr> <tr> <td>15</td> <td><a href=#15>Що таке функція каррінг</a></td> </tr> <tr> <td>16</td> <td><a href=#16>Що таке чиста функція</a></td> </tr> <tr> <td>17</td> <td><a href=#17-let>Яка мета ключового слова let</a></td> </tr> <tr> <td>18</td> <td><a href=#18-let-var>В чому різниця між let та var</a></td> </tr> <tr> <td>19</td> <td><a href=#19-let>Яка причина вибору назви let як ключового слова</a></td> </tr> <tr> <td>20</td> <td><a href=#20-switch>Як перевизначити змінні в switch блоку без помилки</a></td> </tr> <tr> <td>21</td> <td><a href=#21>Що таке Тимчасова мертва зона</a></td> </tr> <tr> <td>22</td> <td><a href=#22-iife>Що таке Негайно Викликані Функціональні Вирази (IIFE)</a></td> </tr> <tr> <td>23</td> <td><a href=#23-url-javascript>Як декодувати або закодувати URL в JavaScript?</a></td> </tr> <tr> <td>24</td> <td><a href=#24>Що таке мемоізація</a></td> </tr> <tr> <td>25</td> <td><a href=#25>Що таке Хойстінг</a></td> </tr> <tr> <td>26</td> <td><a href=#26-es6>Що таке класи в ES6</a></td> </tr> <tr> <td>27</td> <td><a href=#27>Що таке замикання</a></td> </tr> <tr> <td>28</td> <td><a href=#28>Що таке модулі</a></td> </tr> <tr> <td>29</td> <td><a href=#29>Чому вам потрібні модулі</a></td> </tr> <tr> <td>30</td> <td><a href=#30-javascript>Що таке область видимості в JavaScript</a></td> </tr> <tr> <td>31</td> <td><a href=#31-service-worker>Що таке сервісний працівник (service worker)</a></td> </tr> <tr> <td>32</td> <td><a href=#32-dom-service-worker>Як ви змінюєте DOM, використовуючи сервісний працівник (service worker)</a></td> </tr> <tr> <td>33</td> <td><a href=#33-service-worker>Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker)</a></td> </tr> <tr> <td>34</td> <td><a href=#34-indexeddb>Що таке IndexedDB</a></td> </tr> <tr> <td>35</td> <td><a href=#35-web-storage>Що таке веб-сховище (web storage)</a></td> </tr> <tr> <td>36</td> <td><a href=#36-post-message>Що таке пост-повідомлення (post message)</a></td> </tr> <tr> <td>37</td> <td><a href=#37-cookie>Що таке кука (cookie)</a></td> </tr> <tr> <td>38</td> <td><a href=#38-cookie>Чому вам потрібна кука (cookie)</a></td> </tr> <tr> <td>39</td> <td><a href=#39-cookie>Які параметри куки (cookie)</a></td> </tr> <tr> <td>40</td> <td><a href=#40-cookie>Як видаляти куку (cookie)</a></td> </tr> <tr> <td>41</td> <td><a href=#41-local-storage-session-storage>Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage)</a></td> </tr> <tr> <td>42</td> <td><a href=#42-localstorage-sessionstorage>Яка основна різниця між localStorage та sessionStorage</a></td> </tr> <tr> <td>43</td> <td><a href=#43-web-storage>Як отримати доступ до веб-сховища (web storage)</a></td> </tr> <tr> <td>44</td> <td><a href=#44-session-storage>Які методи доступні для сеансового сховища (session storage)</a></td> </tr> <tr> <td>45</td> <td><a href=#45-storage-event-event-handler>Що таке подія сховища (storage event) та його обробник події (event handler)</a></td> </tr> <tr> <td>46</td> <td><a href=#46-web-storage>Чому вам потрібне веб-сховище (web storage)</a></td> </tr> <tr> <td>47</td> <td><a href=#47-browser-support>Як перевірити підтримку веб-сховища браузером (browser support)</a></td> </tr> <tr> <td>48</td> <td><a href=#48-browser-support>Як перевірити підтримку веб-працівників браузером (browser support)</a></td> </tr> <tr> <td>49</td> <td><a href=#49-web-worker>Надайте приклад веб-працівника (web worker)</a></td> </tr> <tr> <td>50</td> <td><a href=#50-dom>Які обмеження веб-працівників на DOM</a></td> </tr> <tr> <td>51</td> <td><a href=#51-promise>Що таке обіцянка (promise)</a></td> </tr> <tr> <td>52</td> <td><a href=#52-promise>Чому вам потрібна обіцянка (promise)</a></td> </tr> <tr> <td>53</td> <td><a href=#53-promise>Які три стани у обіцянки (promise)</a></td> </tr> <tr> <td>54</td> <td><a href=#54-callback-function>Що таке зворотний виклик (callback function)</a></td> </tr> <tr> <td>55</td> <td><a href=#55-callbacks>Чому нам потрібні зворотні виклики (callbacks)</a></td> </tr> <tr> <td>56</td> <td><a href=#56-callback-hell>Що таке "інферно зворотніх викликів" (callback hell)</a></td> </tr> <tr> <td>57</td> <td><a href=#57-server-sent-events>Що таке події, відправлені з сервера (server-sent events)</a></td> </tr> <tr> <td>58</td> <td><a href=#58-server-sent-events>Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events)</a></td> </tr> <tr> <td>59</td> <td><a href=#59-server-sent-events>Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events)</a></td> </tr> <tr> <td>60</td> <td><a href=#60-server-sent-events>Які події доступні для подій, відправлених з сервера (server-sent events)</a></td> </tr> <tr> <td>61</td> <td><a href=#61-promise>Які основні правила обіцянок (promise)</a></td> </tr> <tr> <td>62</td> <td><a href=#62-callback-in-callback>Що таке зворотній виклик у зворотньому виклику (callback in callback)</a></td> </tr> <tr> <td>63</td> <td><a href=#63-promise-chaining>Що таке ланцюг обіцянок (promise chaining)</a></td> </tr> <tr> <td>64</td> <td><a href=#64-promiseall>Що таке promise.all</a></td> </tr> <tr> <td>65</td> <td><a href=#65-race-promise>Яка мета методу race у обіцянок (promise)</a></td> </tr> <tr> <td>66</td> <td><a href=#66-javascript-strict-mode>Що таке строгий режим у JavaScript (strict mode)</a></td> </tr> <tr> <td>67</td> <td><a href=#67-strict-mode>Чому вам потрібен строгий режим (strict mode)</a></td> </tr> <tr> <td>68</td> <td><a href=#68-strict-mode>Як ви оголошуєте строгий режим (strict mode)</a></td> </tr> <tr> <td>69</td> <td><a href=#69-double-exclamation>Яка мета подвійного оклику (!!) (double exclamation)</a></td> </tr> <tr> <td>70</td> <td><a href=#70-delete>Яка мета оператора delete</a></td> </tr> <tr> <td>71</td> <td><a href=#71-typeof>Який оператор typeof</a></td> </tr> <tr> <td>72</td> <td><a href=#72-undefined>Що таке властивість undefined</a></td> </tr> <tr> <td>73</td> <td><a href=#73-null>Що таке значення null</a></td> </tr> <tr> <td>74</td> <td><a href=#74-null-undefined>Яка різниця між значенням null та undefined</a></td> </tr> <tr> <td>75</td> <td><a href=#75-eval>Що таке функція eval</a></td> </tr> <tr> <td>76</td> <td><a href=#76-window-тdocument>Яка різниця між об'єктом window та document</a></td> </tr> <tr> <td>77</td> <td><a href=#77-javascript>Як ви отримуєте доступ до історії у JavaScript</a></td> </tr> <tr> <td>78</td> <td><a href=#78-caps-lock>Як ви визначаєте, чи включена клавіша Caps Lock, чи ні</a></td> </tr> <tr> <td>79</td> <td><a href=#79-isnan>Що таке функція isNaN</a></td> </tr> <tr> <td>80</td> <td><a href=#80-undefined>Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined</a></td> </tr> <tr> <td>81</td> <td><a href=#81>Що таке глобальні змінні</a></td> </tr> <tr> <td>82</td> <td><a href=#82>Які проблеми із глобальними змінними</a></td> </tr> <tr> <td>83</td> <td><a href=#83-nan>Що таке властивість NaN</a></td> </tr> <tr> <td>84</td> <td><a href=#84-isfinite>Яка мета функції isFinite</a></td> </tr> <tr> <td>85</td> <td><a href=#85-event-flow>Що таке потік подій (event flow)</a></td> </tr> <tr> <td>86</td> <td><a href=#86-event-bubbling>Що таке всплиття подій (event bubbling)</a></td> </tr> <tr> <td>87</td> <td><a href=#87-event-capturing>Що таке захоплення подій (event capturing)</a></td> </tr> <tr> <td>88</td> <td><a href=#88-javascript>Як ви відправляєте форму за допомогою JavaScript</a></td> </tr> <tr> <td>89</td> <td><a href=#89>Як ви знаходите деталі операційної системи</a></td> </tr> <tr> <td>90</td> <td><a href=#90-load-domcontentloaded>Яка різниця між подіями document load та DOMContentLoaded</a></td> </tr> <tr> <td>91</td> <td><a href=#91-host-user>Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами</a></td> </tr> <tr> <td>92</td> <td><a href=#92-javascript>Які інструменти або техніки використовуються для відлагодження коду JavaScript</a></td> </tr> <tr> <td>93</td> <td><a href=#93-promises-callbacks>Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks)</a></td> </tr> <tr> <td>94</td> <td><a href=#94-property>Яка різниця між атрибутом та властивістю (property)</a></td> </tr> <tr> <td>95</td> <td><a href=#95-same-origin-policy>Що таке політика однакового походження (same-origin policy)</a></td> </tr> <tr> <td>96</td> <td><a href=#96-void-0>Яка мета фрази void 0</a></td> </tr> <tr> <td>97</td> <td><a href=#97-javascript>Чи є JavaScript компільованою чи інтерпретованою мовою</a></td> </tr> <tr> <td>98</td> <td><a href=#98-javascript>Чи є JavaScript чутливою до регістру мовою</a></td> </tr> <tr> <td>99</td> <td><a href=#99-java-javascript>Чи існує якась зв'язок між Java та JavaScript</a></td> </tr> <tr> <td>100</td> <td><a href=#100-events>Що таке події (events)</a></td> </tr> </tbody> </table> <h1 id=-javascript>Відповіді - 'JavaScript'<a class=headerlink href=#-javascript title="Permanent link">&para;</a></h1> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=1-javascript>1. Які існують способи створення обєктів у JavaScript<a class=headerlink href=#1-javascript title="Permanent link">&para;</a></h3> <p>Існує багато способів створення об'єктів у javascript, як показано нижче</p> <ol> <li> <p><strong>Конструктор об'єктів:</strong></p> <p>Найпростіший спосіб створення порожнього об'єкта - використання конструктора об'єктів. Наразі такий підхід не рекомендується.</p> <p><code>javascript var object = new Object();</code></p> </li> <li> <p><strong>Метод створення об'єкту Object:</strong></p> <p>Метод create об'єкту Object створює новий об'єкт, передаючи в якості параметру об'єкт-прототип</p> <p><code>javascript var object = Object.create(null);</code></p> </li> <li> <p><strong>Синтаксис літералів об'єктів:</strong></p> <p>Синтаксис літералів об'єкта (або ініціалізатор об'єкта) - це відокремлений комами набір пар ім'я-значення, обгорнутий фігурними дужками.</p> <p>```javascript var object = { name: "Sudheer", age: 34 };</p> <p>Значення властивостей об'єктних літералів можуть бути будь-якого типу даних, включаючи масив, функцію та вкладений об'єкт. ```</p> <p><strong>Примітка:</strong> Це найпростіший спосіб створення об'єкта</p> </li> <li> <p><strong>Конструктор функцій:</strong></p> <p>Створіть будь-яку функцію і застосуйте оператор new для створення екземплярів об'єктів,</p> <p><code>javascript function Person(name) { this.name = name; this.age = 21; } var object = new Person("Sudheer");</code></p> </li> <li> <p><strong>Конструктор функції з прототипом:</strong></p> <p>Подібно до конструктора функцій, але використовує прототип для їх властивостей та методів,</p> <p><code>javascript function Person() {} Person.prototype.name = "Sudheer"; var object = new Person();</code></p> <p>Це еквівалентно створенню екземпляра за допомогою методу створення об'єкта з прототипом функції, а потім виклику цієї функції з екземпляром і параметрами в якості аргументів.</p> <p>```javascript function func() {};</p> <p>new func(x, y, z); ```</p> <p><strong>(АБО)</strong></p> <p>```javascript // Створити новий екземпляр з використанням прототипу функції. var newInstance = Object.create(func.prototype)</p> <p>// Викликати функцію var result = func.call(newInstance, x, y, z),</p> <p>// Якщо результат є ненульовим об'єктом, використовуйте його, інакше просто використовуйте новий екземпляр. console.log(result &amp;&amp; typeof result === 'object' ? result : newInstance); ```</p> </li> <li> <p><strong>Синтаксис класів у ES6:</strong> *Синтаксис класів у ES6</p> <p>У ES6 введено клас для створення об'єктів</p> <p>```javascript class Person { constructor(name) { this.name = name; } }</p> <p>var object = new Person("Sudheer"); ```</p> </li> <li> <p><strong>Шаблон синглетону:</strong></p> <p>Синглтон - це об'єкт, який може бути створений лише один раз. Повторні виклики його конструктора повертають той самий екземпляр, і таким чином можна гарантувати, що випадково не буде створено декілька екземплярів.</p> <p><code>javascript var object = new (function () { this.name = "Sudheer"; })();</code></p> </li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=2>2. Що таке ланцюг прототипів<a class=headerlink href=#2 title="Permanent link">&para;</a></h3> <p><strong>Ланцюжок прототипів</strong> використовується для створення нових типів об'єктів на основі існуючих. Це схоже на успадкування у мовах, заснованих на класах.</p> <p>Прототип на екземплярі об'єкта доступний через <strong>Object.getPrototypeOf(object)</strong> або властивість <strong>__proto__</strong>, тоді як прототип на функції конструктора доступний через <strong>Object.prototype</strong>.</p> <p><img alt=Скріншот src=images/prototype_chain.png></p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=3-call-apply-bind>3. В чому різниця між методами Call, Apply та Bind<a class=headerlink href=#3-call-apply-bind title="Permanent link">&para;</a></h3> <p>Різницю між методами Call, Apply та Bind можна пояснити за допомогою наступних прикладів,</p> <p><strong>Виклик:</strong> Метод call() викликає функцію із заданим значенням <code>this</code> і аргументами, що надаються один за одним</p> <p>```javascript var employee1 = { firstName: "John", lastName: "Rodson" }; var employee2 = { firstName: "Jimmy", lastName: "Baily" };</p> <p>function invite(greeting1, greeting2) { console.log( greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2 ); }</p> <p>invite.call(employee1, "Hello", "How are you?"); // Привіт Джон Родсон, як справи? invite.call(employee2, "Hello", "How are you?"); // Привіт Джиммі Бейлі, як справи? ```</p> <p><strong>Apply:</strong> Викликає функцію з заданим значенням <code>this</code> і дозволяє передавати аргументи у вигляді масиву</p> <p>```javascript var employee1 = { firstName: "John", lastName: "Rodson" }; var employee2 = { firstName: "Jimmy", lastName: "Baily" };</p> <p>function invite(greeting1, greeting2) { console.log( greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2 ); }</p> <p>invite.apply(employee1, ["Hello", "How are you?"]); // Привіт Джон Родсон, як справи? invite.apply(employee2, ["Hello", "How are you?"]); // Привіт Джиммі Бейлі, як справи? ```</p> <p><strong>bind:</strong> повертає нову функцію, що дозволяє передавати будь-яку кількість аргументів</p> <p>```javascript var employee1 = { firstName: "John", lastName: "Rodson" }; var employee2 = { firstName: "Jimmy", lastName: "Baily" };</p> <p>function invite(greeting1, greeting2) { console.log( greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2 ); }</p> <p>var inviteEmployee1 = invite.bind(employee1); var inviteEmployee2 = invite.bind(employee2); inviteEmployee1("Hello", "How are you?"); // Привіт Джон Родсон, як справи? inviteEmployee2("Hello", "How are you?"); // Привіт, Джиммі Бейлі, як справи? ```</p> <p>Виклик і застосування практично взаємозамінні. Обидва вони негайно виконують поточну функцію. Вам потрібно вирішити, що простіше - надсилати масив або список аргументів, розділених комами. Ви можете запам'ятати, розглядаючи Call як <strong>comma</strong> (відокремлений список), а Apply як <strong>Array</strong> (масив).</p> <p>Тоді як Bind створює нову функцію, яка матиме <code>this</code> як перший параметр, переданий до bind().</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=4-json>4. Що таке JSON та його загальні операції<a class=headerlink href=#4-json title="Permanent link">&para;</a></h3> <p><strong>JSON</strong> - це текстовий формат даних, що відповідає об'єктному синтаксису JavaScript, який популяризував Дуглас Крокфорд (Douglas Crockford). Він корисний, коли ви хочете передати дані через мережу, і являє собою просто текстовий файл з розширенням .json і MIME-типом application/json.</p> <p><strong>Синтаксичний аналіз:</strong> Перетворення рядка в нативний об'єкт</p> <p><code>javascript JSON.parse(text);</code></p> <p><strong>Структурування:</strong> перетворення нативного об'єкта в рядок для передачі по мережі</p> <p><code>javascript JSON.stringify(object);</code></p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=5-slice>5. Яка мета методу slice для масиву<a class=headerlink href=#5-slice title="Permanent link">&para;</a></h3> <p>Метод <strong>slice()</strong> повертає вибрані елементи масиву у вигляді нового об'єкта масиву. Він вибирає елементи, починаючи з заданого початкового аргументу, і закінчуючи заданим необов'язковим кінцевим аргументом, не включаючи останній елемент. Якщо ви опустите другий аргумент, то вибірка буде виконуватися до кінця.</p> <p>Деякі приклади використання цього методу наведено нижче,</p> <p><code>javascript let arrayIntegers = [1, 2, 3, 4, 5]; let arrayIntegers1 = arrayIntegers.slice(0, 2); // повертає [1,2] let arrayIntegers2 = arrayIntegers.slice(2, 3); // повертає [3] let arrayIntegers3 = arrayIntegers.slice(4); //повертається [5]</code></p> <p><strong>Примітка:</strong> Метод slice не мутує оригінальний масив, але повертає підмножину у вигляді нового масиву.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=6-splice>6. Яка мета методу splice для масиву<a class=headerlink href=#6-splice title="Permanent link">&para;</a></h3> <p>Метод <strong>splice()</strong> використовується або для додавання/видалення елементів до/з масиву, а потім повертає видалений елемент. Перший аргумент вказує позицію в масиві для вставки або видалення, тоді як необов'язковий другий аргумент вказує кількість елементів, які потрібно видалити. Кожен додатковий аргумент додається до масиву.</p> <p>Деякі приклади використання цього методу наведено нижче:</p> <pre><code class=language-javascript>let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

let arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); // повертає [1, 2]; вихідний масив: [3, 4, 5]
let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // повертає [4, 5]; вихідний масив: [1, 2, 3]
let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); //повертає [4]; вихідний масив: [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 5]
</code></pre> <p><strong>Примітка:</strong> Метод Splice модифікує вихідний масив і повертає видалений масив.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=7-slice-splice>7. В чому різниця між slice та splice<a class=headerlink href=#7-slice-splice title="Permanent link">&para;</a></h3> <p>Деякі основні відмінності в табличній формі:</p> <table> <thead> <tr> <th>Slice</th> <th>Splice</th> </tr> </thead> <tbody> <tr> <td>Не модифікує вихідний масив (незмінний)</td> <td>Модифікує вихідний масив (змінюваний)</td> </tr> <tr> <td>Повертає підмножину вихідного масиву</td> <td>Повертає видалені елементи як масив</td> </tr> <tr> <td>Використовується для вибору елементів з масиву</td> <td>Використовується для вставки або видалення елементів в/з масиву</td> </tr> </tbody> </table> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=8-map>8. Як порівняти Об'єкт із Map<a class=headerlink href=#8-map title="Permanent link">&para;</a></h3> <p><strong>Об'єкти</strong> схожі на мапи у тому, що обидва дозволяють встановлювати ключі для значень, отримувати ці значення, видаляти ключі та визначати, чи зберігається щось за ключем. З цієї причини об'єкти історично використовувалися як мапи. Але існують важливі відмінності, які роблять використання мапи кращим у певних випадках.</p> <ol> <li>Ключами об'єкта є рядки та символи, тоді як для мапи вони можуть бути будь-якими значеннями, включаючи функції, об'єкти та будь-які примітиви.</li> <li>Ключі на карті впорядковані, а ключі, додані до об'єкта, ні. Таким чином, при ітерації над об'єктом Map повертає ключі у порядку їх додавання.</li> <li>Розмір Map можна легко отримати за допомогою властивості size, в той час як кількість властивостей в Object потрібно визначати вручну.</li> <li>Мапа є ітерабельним об'єктом і тому може бути безпосередньо ітерабельною, в той час як ітерація над Об'єктом вимагає отримання його ключів та ітерації над ними.</li> <li>Об'єкт має прототип, тому на карті є ключі за замовчуванням, які можуть зіткнутися з вашими ключами, якщо ви не будете обережними. Починаючи з ES5 це можна обійти за допомогою map = Object.create(null), але це рідко робиться.</li> <li>Карта може працювати краще у сценаріях, що передбачають часте додавання та видалення пар ключів.</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=9>9. В чому різниця між операторами == та ===<a class=headerlink href=#9 title="Permanent link">&para;</a></h3> <p>JavaScript забезпечує як строге <code>(===, !==)</code>, так і привідне <code>(==, !=)</code> порівняння на рівність. Строгі оператори беруть до уваги тип змінної, в той час як нестрогі оператори виконують корекцію/перетворення типу на основі значень змінних. Строгі оператори виконують наступні умови для різних типів,</p> <ol> <li>Два рядки є строго рівними, якщо вони мають однакову послідовність символів, однакову довжину і однакові символи у відповідних позиціях.</li> <li>Два числа є строго рівними, якщо вони є чисельно рівними, тобто мають однакове числове значення. Існує два особливих випадки,<ol> <li>NaN не дорівнює ніякому числу, включаючи NaN.</li> <li>Додатні та від'ємні нулі дорівнюють один одному.</li> </ol> </li> <li>Два булевих операнди строго рівні, якщо обидва істинні або обидва хибні.</li> <li>Два об'єкти строго рівні, якщо вони посилаються на один і той самий об'єкт.</li> <li>Типи <code>Null та Undefined не рівні з ===, але рівні з ==</code>, тобто <code>null === undefined --&gt; false</code>, але <code>null ==u ndefined --&gt; true</code></li> </ol> <p>Декілька прикладів, які охоплюють вищезгадані випадки,</p> <pre><code class=language-javascript>0 == false // true
0 === false // false
1 == &quot;1&quot; // true
1 === &quot;1&quot; // false
null == undefined // true
null === undefined // false
'0' == false // true
'0' === false // false
[]==[] або []===[] //false, посилаються на різні об'єкти в пам'яті
{}=={} або {}==={} //неправда, посилаються на різні об'єкти в пам'яті
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=10->10. Що таке лямбда- або стрілкові функції<a class=headerlink href=#10- title="Permanent link">&para;</a></h3> <p>Функція-стрілка - це коротший синтаксис виразу функції, який не має власних <strong>this, arguments, super або new.target</strong>.<br> Ці функції найкраще підходять для функцій, що не є методами, і їх не можна використовувати як конструктори.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=11>11. Що таке функція першого класу<a class=headerlink href=#11 title="Permanent link">&para;</a></h3> <p>У Javascript функції є об'єктами першого класу. Першокласні функції означають, що функції в цій мові поводяться так само, як і будь-які інші змінні.</p> <p>Наприклад, у такій мові функцію можна передавати як аргумент іншим функціям, повертати іншою функцією і присвоювати як значення змінній. Наприклад, у наведеному нижче прикладі функції-оброблювачі, присвоєні слухачеві</p> <pre><code class=language-javascript>const handler = () =&gt; console.log(&quot;Це функція обробки кліку&quot;);
document.addEventListener(&quot;click&quot;, handler);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=12>12. Що таке функція першого порядку<a class=headerlink href=#12 title="Permanent link">&para;</a></h3> <p>Функція першого порядку - це функція, яка не приймає іншу функцію як аргумент і не повертає функцію як своє значення.</p> <pre><code class=language-javascript>const firstOrder = () =&gt; console.log(&quot;Я функція першого порядку!&quot;);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=13>13. Що таке функція вищого порядку<a class=headerlink href=#13 title="Permanent link">&para;</a></h3> <p>Функція вищого порядку - це функція, яка приймає іншу функцію як аргумент або повертає функцію як значення, що повертається, або і те, і інше.</p> <pre><code class=language-javascript>const firstOrderFunc = () =&gt; ...
  console.log(&quot;Привіт, я функція першого порядку&quot;);
const higherOrder = (ReturnFirstOrderFunc) =&gt; ReturnFirstOrderFunc();
higherOrder(firstOrderFunc);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=14>14. Що таке унарна функція<a class=headerlink href=#14 title="Permanent link">&para;</a></h3> <p>Унарна функція (тобто монада) - це функція, яка приймає рівно один аргумент. Вона позначає єдиний аргумент, який приймає функція.</p> <p>Розглянемо приклад унарної функції:</p> <pre><code class=language-javascript>const unaryFunction = (a) =&gt; console.log(a + 10); // Додати до заданого аргументу 10 і вивести значення
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=15>15. Що таке функція каррінг<a class=headerlink href=#15 title="Permanent link">&para;</a></h3> <p>Каррінг - це процес перетворення функції з декількома аргументами на послідовність функцій, кожна з яких має лише один аргумент. Каррінг названо на честь математика <strong>Гаскелла Каррі</strong>. Застосовуючи каррінг, n-арна функція перетворюється на унарну функцію.</p> <p>Розглянемо приклад n-арної функції і те, як вона перетворюється на функцію каррі,</p> <pre><code class=language-javascript>const multiArgFunction = (a, b, c) =&gt; a + b + c;
console.log(multiArgFunction(1, 2, 3)); // 6

const curryUnaryFunction = (a) =&gt; (b) =&gt; (c) =&gt; a + b + c;
curryUnaryFunction(1); // повертає функцію: b =&gt; c =&gt; 1 + b + c
curryUnaryFunction(1)(2); // повертає функцію: c =&gt; 3 + c
curryUnaryFunction(1)(2)(3); // повертає число 6
</code></pre> <p>Функції каррі чудово підходять для покращення <strong>можливості повторного використання коду</strong> та <strong>функціонального складу</strong>.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=16>16. Що таке чиста функція<a class=headerlink href=#16 title="Permanent link">&para;</a></h3> <p>Чиста функція - це функція, значення, що повертається, визначається лише її аргументами без будь-яких побічних ефектів, тобто якщо ви викликаєте функцію з тими самими аргументами "n" разів і "n" місць у програмі, вона завжди повертатиме одне й те саме значення.</p> <p>Розглянемо на прикладі різницю між чистими і нечистими функціями:</p> <pre><code class=language-javascript>//Нечиста
let numberArray = [];
const impureAddNumber = (number) =&gt; numberArray.push(number);
//Чистий
const pureAddNumber = (number) =&gt; (argNumberArray) =&gt; (numberArray)
argNumberArray.concat([number]);

//Вивести результати
console.log(impureAddNumber(6)); // повертає 1
console.log(numberArray); // повертає [6]
console.log(pureAddNumber(7)(numberArray)); // повертає [6, 7]
console.log(numberArray); // повертає [6]
</code></pre> <p>Як видно з вищенаведених фрагментів коду, функція <strong>Push</strong> сама є нечистою, оскільки змінює масив і повертає індекс числа, що проштовхується, незалежно від значення параметра. . Тоді як <strong>Concat</strong>, навпаки, бере масив і об'єднує його з іншим масивом, створюючи абсолютно новий масив без побічних ефектів. Крім того, значення, що повертається, є конкатенацією попереднього масиву.</p> <p>Пам'ятайте, що чисті функції важливі, оскільки вони спрощують модульне тестування без побічних ефектів і не потребують ін'єкції залежностей. Вони також уникають тісного зв'язку і ускладнюють злам вашої програми, оскільки не мають побічних ефектів. Ці принципи поєднуються з концепцією <strong>Immutability</strong> в ES6, надаючи перевагу використанню <strong>const</strong> над <strong>let</strong>.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=17-let>17. Яка мета ключового слова let<a class=headerlink href=#17-let title="Permanent link">&para;</a></h3> <p>Інструкція <code>let</code> оголошує локальну змінну з областю видимості <strong>блоку</strong>. Таким чином, змінні, визначені з ключовим словом let, обмежені в області видимості блоком, оператором або виразом, в якому вони використовуються. Тоді як змінні, оголошені з ключовим словом <code>var</code>, використовуються для визначення змінної глобально або локально для всієї функції незалежно від області видимості блоку.</p> <p>Розглянемо приклад, щоб продемонструвати використання:</p> <pre><code class=language-javascript>let counter = 30;
if (counter === 30) {
  let counter = 31;
  console.log(counter); // 31
}
console.log(counter); // 30 (тому що змінної в блоці if тут не буде)
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=18-let-var>18. В чому різниця між let та var<a class=headerlink href=#18-let-var title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>var</th> <th>let</th> </tr> </thead> <tbody> <tr> <td>Був доступний з самого початку JavaScript</td> <td>Представлений як частина ES6</td> </tr> <tr> <td>Має область видимості функції</td> <td>Має область видимості блоку</td> </tr> <tr> <td>Змінні будуть підняті</td> <td>Підняті, але не ініціалізовані</td> </tr> </tbody> </table> <p>Давайте розглянемо приклад, щоб побачити різницю:</p> <pre><code class=language-javascript>function userDetails(user_name) {
  if (user_name) {
    console.log(salary); // невизначено через підняття
    console.log(age); // ReferenceError: Неможливо отримати доступ до 'age' до ініціалізації
    let age = 30;
    var salary = 10000;
  }
  console.log(salary); //10000 (доступно з області видимості функції)
  console.log(age); //помилка: вік не визначений(через область видимості блоку)
}
userDetails(&quot;John&quot;);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=19-let>19. Яка причина вибору назви let як ключового слова<a class=headerlink href=#19-let title="Permanent link">&para;</a></h3> <p><code>let</code> - це математичний оператор, який був прийнятий у ранніх мовах програмування, таких як <strong>Scheme</strong> та <strong>Basic</strong>. Його було запозичено з десятків інших мов, які використовують <code>let</code> вже як традиційне ключове слово, максимально наближене до <code>var</code>.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=20-switch>20. Як перевизначити змінні в switch блоку без помилки<a class=headerlink href=#20-switch title="Permanent link">&para;</a></h3> <p>Якщо ви спробуєте перевизначити змінні в "блоці перемикачів", то це призведе до помилок, оскільки існує лише один блок. Наприклад, наведений нижче блок коду викликає синтаксичну помилку, як показано нижче,</p> <pre><code class=language-javascript>let counter = 1;
switch (x) {
  case 0
    let name;
    break

  case 1:
    let name; // Синтаксична помилка при перевизначенні.
    break;
}
</code></pre> <p>Щоб уникнути цієї помилки, ви можете створити вкладений блок всередині case-речення і створити нове блокове лексичне оточення.</p> <pre><code class=language-javascript>let counter = 1;
switch (x) {
  case 0: {
    let name;
    break;
  }
  case 1: {
    let name; // Немає синтаксичної помилки при перевизначенні.
    break;
  }
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=21>21. Що таке Тимчасова мертва зона<a class=headerlink href=#21 title="Permanent link">&para;</a></h3> <p>Тимчасова мертва зона - це поведінка в JavaScript, яка виникає при оголошенні змінної з ключовими словами let і const, але не з var. В ECMAScript 6 доступ до змінної <code>let</code> або <code>const</code> до її оголошення (в межах її області видимості) викликає помилку посилання. Проміжок часу, коли це відбувається, між створенням прив'язки змінної та її оголошенням, називається тимчасовою мертвою зоною.</p> <p>Розглянемо таку поведінку на прикладі:</p> <pre><code class=language-javascript>function somemethod() {
  console.log(counter1); // undefined
  console.log(counter2); // ReferenceError
  var counter1 = 1;
  let counter2 = 2;
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=22-iife>22. Що таке Негайно Викликані Функціональні Вирази (IIFE)<a class=headerlink href=#22-iife title="Permanent link">&para;</a></h3> <p>IIFE (Immediately Invoked Function Expression) - це функція JavaScript, яка виконується одразу після її визначення. Її підпис буде таким, як показано нижче,</p> <pre><code class=language-javascript>(function () {
  // логіка тут
})();
</code></pre> <p>Основною причиною використання IIFE є забезпечення конфіденційності даних, оскільки будь-які змінні, оголошені в IIFE, не можуть бути доступні ззовні. Тобто, якщо ви намагаєтесь отримати доступ до змінних за допомогою IIFE, він видасть помилку, як показано нижче,</p> <pre><code class=language-javascript>(function () {
  var message = &quot;IIFE&quot;;
  console.log(message);
})();
console.log(message); //Ошибка: повідомлення не визначено
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=23-url-javascript>23. Як декодувати або закодувати URL в JavaScript?<a class=headerlink href=#23-url-javascript title="Permanent link">&para;</a></h3> <p>Функція <code>encodeURI()</code> використовується для кодування URL-адреси. Ця функція отримує в якості параметра рядок URL-адреси і повертає закодований рядок. Функція <code>decodeURI()</code> використовується для декодування URL-адреси. Ця функція отримує закодований рядок URL як параметр і повертає декодований рядок.</p> <p><strong>Примітка:</strong> Якщо ви хочете закодувати такі символи, як <code>/ ? : @ &amp; = + $ #</code>, то вам слід використовувати <code>encodeURIComponent()</code>.</p> <pre><code class=language-javascript>let uri = &quot;employeeDetails?name=john&amp;occupation=manager&quot;;
let encoded_uri = encodeURI(uri);
let decoded_uri = decodeURI(encoded_uri);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=24>24. Що таке мемоізація<a class=headerlink href=#24 title="Permanent link">&para;</a></h3> <p>Memoization (Запам'ятовування) - це техніка програмування, яка намагається підвищити продуктивність функції шляхом кешування її попередньо обчислених результатів. Кожного разу, коли викликається функція, що запам'ятовується, її параметри використовуються для індексації кешу. Якщо дані є, то їх можна повернути, не виконуючи всю функцію. В іншому випадку функція виконується, а потім результат додається до кешу. Розглянемо приклад додавання функції із запам'ятовуванням,</p> <pre><code class=language-javascript>const memoizAddition = () =&gt; {
  let cache = {};
  return (value) =&gt; {
    if (value in cache) {
      console.log(&quot;Вибірка з кешу&quot;);
      return cache[value]; // Тут cache.value не може бути використано, оскільки назва властивості починається з цифри, яка не є коректним ідентифікатором JavaScript. Отже, доступ до нього можливий лише з використанням квадратних дужок.
    } else {
      console.log(&quot;Обчислюємо результат&quot;);
      let result = value + 20;
      cache[value] = result;
      return result;
    }
  };
};
// функція, що повертається з memoizAddition
const addition = memoizAddition();
console.log(addition(20)); //виведення: 40 обчислено
console.log(addition(20)); //виведення: 40 кешовано
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=25>25.Що таке Хойстінг<a class=headerlink href=#25 title="Permanent link">&para;</a></h3> <p>Hoisting - це механізм JavaScript, за допомогою якого змінні, оголошення функцій і класів переміщуються на початок їхньої області видимості перед виконанням коду. Пам'ятайте, що JavaScript піднімає тільки оголошення, а не ініціалізацію. Розглянемо простий приклад підйому змінної,</p> <pre><code class=language-javascript>console.log(message); //вихід : undefined
var message = &quot;Змінна була піднята&quot;;
</code></pre> <p>Вищенаведений код для інтерпретатора виглядає так, як показано нижче,</p> <pre><code class=language-javascript>var message;
console.log(message);
message = &quot;Змінна була піднята&quot;;
</code></pre> <p>Таким же чином піднімаються оголошення функцій</p> <pre><code class=language-javascript>message(&quot;Good morning&quot;); //Доброго ранку

function message(name) {
  console.log(name);
}
</code></pre> <p>Цей підйом дозволяє безпечно використовувати функції у коді до їх оголошення.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=26-es6>26. Що таке класи в ES6<a class=headerlink href=#26-es6 title="Permanent link">&para;</a></h3> <p>В ES6 класи Javascript - це насамперед синтаксичний цукор у порівнянні з існуючим успадкуванням JavaScript на основі прототипів. Наприклад, успадкування на основі прототипу, записане у вигляді виразу функції, як показано нижче,</p> <pre><code class=language-javascript>function Bike(model, color) {
  this.model = model;
  this.color = color;
}

Bike.prototype.getDetails = function () {
  return this.model + &quot; велосипед має&quot; + this.color + &quot; колір&quot;;
};
</code></pre> <p>В той час як класи ES6 можуть бути визначені як альтернатива</p> <pre><code class=language-javascript>class Bike {
  constructor(color, model) {
    this.color = color
    this.model = model;
  }

  getDetails() {
    return this.model + &quot; велосипед має&quot; + this.color + &quot; колір&quot;;
  }
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=27>27. Що таке замикання<a class=headerlink href=#27 title="Permanent link">&para;</a></h3> <p>Закриття - це поєднання функції та лексичного оточення, в якому ця функція була оголошена, тобто це внутрішня функція, яка має доступ до змінних зовнішньої або охоплюючої функції.Закриття має три ланцюжки області видимості</p> <ol> <li>Власна область видимості, де змінні визначені між фігурними дужками</li> <li>Змінні зовнішньої функції</li> <li>Глобальні змінні</li> </ol> <p>Розглянемо приклад концепції закриття,</p> <pre><code class=language-javascript>function Welcome(name) {
  var greetingInfo = function (message) {
    console.log(message + &quot; &quot; + name);
  };
  return greetingInfo;
}
var myFunction = Welcome(&quot;John&quot;);
myFunction(&quot;Welcome &quot;); //Output: Welcome John
myFunction(&quot;Hello Mr.&quot;); //output: Hello Mr.John
</code></pre> <p>Як видно з вищенаведеного коду, внутрішня функція (тобто greetingInfo) має доступ до змінних в області видимості зовнішньої функції (тобто Welcome) навіть після того, як зовнішня функція повернулася.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=28>28. Що таке модулі<a class=headerlink href=#28 title="Permanent link">&para;</a></h3> <p>Модулі - це невеликі одиниці незалежного коду, який можна використовувати повторно, а також основа багатьох шаблонів проектування JavaScript. Більшість модулів JavaScript експортують об'єктний літерал, функцію або конструктор</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=29>29. Чому вам потрібні модулі<a class=headerlink href=#29 title="Permanent link">&para;</a></h3> <p>Нижче наведено перелік переваг використання модулів в екосистемі JavaScript</p> <ol> <li>Легкість супроводу</li> <li>Можливість повторного використання</li> <li>Простір імен</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=30-javascript>30. Що таке область видимості в JavaScript<a class=headerlink href=#30-javascript title="Permanent link">&para;</a></h3> <p>Область видимості - це доступність змінних, функцій та об'єктів у певній частині вашого коду під час виконання. Іншими словами, область видимості визначає видимість змінних та інших ресурсів у певних частинах вашого коду.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=31-service-worker>31. Що таке сервісний працівник (service worker)<a class=headerlink href=#31-service-worker title="Permanent link">&para;</a></h3> <p>Сервісний працівник - це, по суті, скрипт (файл JavaScript), який працює у фоновому режимі, окремо від веб-сторінки, і надає функції, які не потребують веб-сторінки або взаємодії з користувачем. Деякі з основних функцій сервісних працівників - це багатий офлайн-досвід (перша розробка веб-додатків в автономному режимі), періодична фонова синхронізація, push-сповіщення, перехоплення та обробка мережевих запитів і програмне керування кешем відповідей.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=32-dom-service-worker>32. Як ви змінюєте DOM, використовуючи сервісний працівник (service worker)<a class=headerlink href=#32-dom-service-worker title="Permanent link">&para;</a></h3> <p>Сервісний працівник не може отримати доступ до DOM безпосередньо. Але він може взаємодіяти зі сторінками, які він контролює, відповідаючи на повідомлення, надіслані через інтерфейс <code>postMessage</code>, і ці сторінки можуть маніпулювати DOM.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=33-service-worker>33. Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker)<a class=headerlink href=#33-service-worker title="Permanent link">&para;</a></h3> <p>Проблема з сервісним працівником полягає у тому, що він завершується, коли не використовується, і перезапускається, коли він потрібен наступного разу, тому ви не можете покладатися на глобальний стан у обробниках <code>onfetch</code> та <code>onmessage</code> сервісного працівника. У цьому випадку сервісні працівники матимуть доступ до API IndexedDB для збереження та повторного використання після перезапуску.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=34-indexeddb>34. Що таке IndexedDB<a class=headerlink href=#34-indexeddb title="Permanent link">&para;</a></h3> <p>IndexedDB - це низькорівневий API для зберігання на стороні клієнта великих обсягів структурованих даних, включаючи файли/блоки. Цей API використовує індекси для забезпечення високопродуктивного пошуку в цих даних.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=35-web-storage>35. Що таке веб-сховище (web storage)<a class=headerlink href=#35-web-storage title="Permanent link">&para;</a></h3> <p>Веб-сховище - це API, який надає механізм, за допомогою якого браузери можуть зберігати пари ключ/значення локально в браузері користувача, в набагато більш інтуїтивно зрозумілий спосіб, ніж використання файлів cookie. Веб-сховище надає два механізми для зберігання даних на клієнті.</p> <ol> <li><strong>Локальне сховище:</strong> Зберігає дані поточного походження без терміну придатності.</li> <li><strong>Сховище сеансів:</strong> Зберігає дані протягом одного сеансу, і дані втрачаються при закритті вкладки браузера.</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=36-post-message>36. Що таке пост-повідомлення (post message)<a class=headerlink href=#36-post-message title="Permanent link">&para;</a></h3> <p>Пост-повідомлення - це метод, який забезпечує перехресний зв'язок між об'єктами Window (наприклад, між сторінкою і спливаючим вікном, яке вона породила, або між сторінкою і вбудованим в неї iframe). Як правило, скриптам на різних сторінках дозволяється доступ один до одного, якщо і тільки якщо сторінки дотримуються політики однакового походження (тобто сторінки використовують один і той самий протокол, номер порту та хост).</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=37-cookie>37. Що таке кука (cookie)<a class=headerlink href=#37-cookie title="Permanent link">&para;</a></h3> <p>Файл cookie - це фрагмент даних, який зберігається на вашому комп'ютері для доступу до нього вашим браузером. Файли cookie зберігаються у вигляді пар ключ/значення. Наприклад, ви можете створити файл cookie з ім'ям користувача, як показано нижче,</p> <pre><code class=language-javascript>document.cookie = &quot;username=John&quot;;
</code></pre> <p><img alt=Скріншот src=images/cookie.png></p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=38-cookie>38. Чому вам потрібна кука (cookie)<a class=headerlink href=#38-cookie title="Permanent link">&para;</a></h3> <p>Файли cookie використовуються для запам'ятовування інформації про профіль користувача (наприклад, ім'я користувача). В основному це відбувається в два етапи,</p> <ol> <li>Коли користувач відвідує веб-сторінку, профіль користувача може бути збережений у файлі cookie.</li> <li>Наступного разу, коли користувач відвідає сторінку, файл cookie запам'ятає профіль користувача.</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=39-cookie>39. Які параметри куки (cookie)<a class=headerlink href=#39-cookie title="Permanent link">&para;</a></h3> <p>Нижче наведено кілька варіантів, доступних для файлів cookie,</p> <ol> <li>За замовчуванням, файл cookie видаляється при закритті браузера, але ви можете змінити цю поведінку, встановивши дату закінчення терміну дії (за часом UTC).</li> </ol> <pre><code class=language-javascript>document.cookie = &quot;username=John; expires=Sat, 10 Jun 2023 10:00:00 UTC&quot;;
</code></pre> <ol> <li>За замовчуванням файл cookie належить поточній сторінці. Але ви можете вказати браузеру, до якого шляху належить файл cookie, за допомогою параметра path.</li> </ol> <pre><code class=language-javascript>document.cookie = &quot;username=John; path=/services&quot;;
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=40-cookie>40. Як видаляти куку (cookie)<a class=headerlink href=#40-cookie title="Permanent link">&para;</a></h3> <p>Ви можете видалити файл cookie, встановивши дату закінчення терміну дії як минулу дату. У цьому випадку вам не потрібно вказувати значення файлу cookie. Наприклад, ви можете видалити файл cookie імені користувача на поточній сторінці, як показано нижче.</p> <pre><code class=language-javascript>document.cookie = &quot;username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;&quot;;
</code></pre> <p><strong>Примітка:</strong> Ви повинні вказати шлях до файлу cookie, щоб переконатися, що ви видаляєте правильний файл cookie. Деякі браузери не дозволяють видаляти файли cookie, якщо ви не вкажете параметр шляху.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=41-local-storage-session-storage>41. Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage)<a class=headerlink href=#41-local-storage-session-storage title="Permanent link">&para;</a></h3> <p>Нижче наведено деякі відмінності між файлами cookie, локальним сховищем і сховищем сеансів,</p> <table> <thead> <tr> <th>Функція</th> <th>Cookie</th> <th>Локальне сховище</th> <th>Сховище сеансів</th> </tr> </thead> <tbody> <tr> <td>Доступ на стороні клієнта або сервера</td> <td>Як на стороні сервера, так і на стороні клієнта</td> <td>Тільки на стороні клієнта</td> <td>Тільки на стороні клієнта</td> </tr> <tr> <td>Термін дії</td> <td>Як налаштовано за допомогою параметра Термін дії</td> <td>до видалення</td> <td>до закриття вкладки</td> </tr> <tr> <td>Підтримка SSL</td> <td>Підтримується</td> <td>Підтримується</td> <td>Не підтримується</td> </tr> <tr> <td>Максимальний розмір даних</td> <td>4 КБ</td> <td>5 МБ</td> <td>5 МБ</td> </tr> </tbody> </table> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=42-localstorage-sessionstorage>42. Яка основна різниця між localStorage та sessionStorage<a class=headerlink href=#42-localstorage-sessionstorage title="Permanent link">&para;</a></h3> <p>LocalStorage - це те ж саме, що і SessionStorage, але воно зберігає дані, навіть коли браузер закривається і відкривається знову (тобто не має терміну придатності), тоді як у sessionStorage дані очищаються після завершення сеансу роботи зі сторінкою.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=43-web-storage>43. Як отримати доступ до веб-сховища (web storage)<a class=headerlink href=#43-web-storage title="Permanent link">&para;</a></h3> <p>Об'єкт Window реалізує об'єкти <code>WindowLocalStorage</code> та <code>WindowSessionStorage</code>, які мають властивості <code>localStorage</code> (window.localStorage) та <code>essionStorage</code> (window.sessionStorage) відповідно. Ці властивості створюють екземпляр об'єкта Storage, за допомогою якого можна встановлювати, отримувати і видаляти елементи даних для певного домену і типу сховища (сеансового або локального). Наприклад, ви можете читати і писати на локальних об'єктах сховища, як показано нижче</p> <pre><code class=language-javascript>localStorage.setItem(&quot;logo&quot;, document.getElementById(&quot;logo&quot;).value);
localStorage.getItem(&quot;logo&quot;);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=44-session-storage>44. Які методи доступні для сеансового сховища (session storage)<a class=headerlink href=#44-session-storage title="Permanent link">&para;</a></h3> <p>У сховищі сесій передбачено методи для читання, запису та очищення даних сесії:</p> <pre><code class=language-javascript>// Зберегти дані в sessionStorage
sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;);

// Отримати збережені дані зі сховища sessionStorage
let data = sessionStorage.getItem(&quot;key&quot;);

// Видалити збережені дані зі сховища sessionStorage
sessionStorage.removeItem(&quot;key&quot;);

// Видалити усі збережені дані зі сховища sessionStorage
sessionStorage.clear();
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=45-storage-event-event-handler>45. Що таке подія сховища (storage event) та його обробник події (event handler)<a class=headerlink href=#45-storage-event-event-handler title="Permanent link">&para;</a></h3> <p>StorageEvent - це подія, яка спрацьовує, коли змінюється область зберігання у контексті іншого документа. Тоді як властивість onstorage є обробником подій для обробки подій зберігання. Синтаксис буде наступним</p> <pre><code class=language-javascript>window.onstorage = functionRef;
</code></pre> <p>Розглянемо приклад використання обробника подій onstorage, який реєструє ключ сховища та його значення</p> <pre><code class=language-javascript>window.onstorage = function (e) {
  console.log(
    &quot;The &quot; +
      e.key +
      &quot; ключ був змінений з &quot; +
      e.oldValue +
      &quot; на &quot; +
      e.newValue +
      &quot;.&quot;
  );
};
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=46-web-storage>46. Чому вам потрібне веб-сховище (web storage)<a class=headerlink href=#46-web-storage title="Permanent link">&para;</a></h3> <p>Веб-сховище більш безпечне, і великі обсяги даних можна зберігати локально, не впливаючи на продуктивність веб-сайту. Крім того, інформація ніколи не передається на сервер. Тому це більш рекомендований підхід, ніж використання файлів cookie.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=47-browser-support>47. Як перевірити підтримку веб-сховища браузером (browser support)<a class=headerlink href=#47-browser-support title="Permanent link">&para;</a></h3> <p>Перед використанням веб-сховища необхідно перевірити підтримку браузером localStorage і sessionStorage,</p> <pre><code class=language-javascript>if (typeof Storage !== &quot;undefined&quot;) {
  // Код для localStorage/sessionStorage.
} else {
  // Вибачте! Веб-сховище не підтримується..
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=48-browser-support>48. Як перевірити підтримку веб-працівників браузером (browser support)<a class=headerlink href=#48-browser-support title="Permanent link">&para;</a></h3> <p>Перш ніж використовувати веб-працівники, потрібно перевірити підтримку браузером</p> <pre><code class=language-javascript>if (typeof Worker !== &quot;undefined&quot;) {
  // код підтримки веб-працівників.
} else {
  // Вибачте! Підтримки Web Worker немає..
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=49-web-worker>49. Надайте приклад веб-працівника (web worker)<a class=headerlink href=#49-web-worker title="Permanent link">&para;</a></h3> <p>Вам потрібно виконати наступні кроки, щоб почати використовувати веб-працівників для прикладу підрахунку</p> <ol> <li>Створіть файл веб-програми: Вам потрібно написати скрипт для збільшення значення лічильника. Назвемо його counter.js</li> </ol> <pre><code class=language-javascript>нехай i = 0;

function timedCount() {
  i = i + 1;
  postMessage(i);
  setTimeout(&quot;timedCount()&quot;, 500);
}

timedCount();
</code></pre> <p>Тут метод postMessage() використовується для відправки повідомлення назад на HTML-сторінку</p> <ol> <li>Створіть об'єкт веб-сервера: Ви можете створити об'єкт веб-працівника, перевіривши підтримку браузером. Назвемо цей файл web_worker_example.js</li> </ol> <pre><code class=language-javascript>if (typeof w == &quot;undefined&quot;) {
  w = new Worker(&quot;counter.js&quot;);
}
</code></pre> <p>і ми можемо отримувати повідомлення від web worker</p> <pre><code class=language-javascript>w.onmessage = function (event) {
  document.getElementById(&quot;message&quot;).innerHTML = event.data;
};
</code></pre> <ol> <li>Завершити роботу веб-працівника: Веб-засоби продовжуватимуть прослуховувати повідомлення (навіть після завершення роботи зовнішнього скрипту), доки їх не буде завершено. Ви можете використовувати метод terminate() для завершення прослуховування повідомлень.</li> </ol> <pre><code class=language-javascript>w.terminate();
</code></pre> <ol> <li>Повторне використання веб-працівника: Якщо ви встановите для змінної worker значення undefined, ви можете повторно використовувати код</li> </ol> <pre><code class=language-javascript>w = undefined;
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=50-dom>50. Які обмеження веб-працівників на DOM<a class=headerlink href=#50-dom title="Permanent link">&para;</a></h3> <p>WebWorker не має доступу до нижченаведених об'єктів javascript, оскільки вони визначені у зовнішніх файлах</p> <ol> <li>Об'єкт вікна</li> <li>Об'єкт документа</li> <li>Батьківський об'єкт</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=51-promise>51. Що таке обіцянка (promise)<a class=headerlink href=#51-promise title="Permanent link">&para;</a></h3> <p>Обіцянка - це об'єкт, який може створити єдине значення колись у майбутньому, або з вирішеним значенням, або з причиною, чому воно не вирішене (наприклад, мережева помилка). Обіцянка перебуватиме в одному з 3 можливих станів: виконана, відхилена або в очікуванні.</p> <p>Синтаксис створення обіцянки виглядає наступним чином,</p> <pre><code class=language-javascript>const promise = new Promise(function (resolve, reject) {
  // опис обіцянки
});
</code></pre> <p>Використання обіцянки буде таким, як показано нижче,</p> <pre><code class=language-javascript>const promise = new Promise()
  (resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve(&quot;Я - обіцянка!&quot;);
    }, 5000);
  },
  (reject) =&gt; {}
);

promise.then((value) =&gt; console.log(value));
</code></pre> <p>Потік дій обіцянки буде таким, як показано нижче,</p> <p><img alt=Скріншот src=images/promises.png></p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=52-promise>52. Чому вам потрібна обіцянка (promise)<a class=headerlink href=#52-promise title="Permanent link">&para;</a></h3> <p>Обіцянки використовуються для обробки асинхронних операцій. Вони забезпечують альтернативний підхід до зворотних викликів, зменшуючи пекло зворотних викликів і дозволяючи писати чистіший код.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=53-promise>53. Які три стани у обіцянки (promise)<a class=headerlink href=#53-promise title="Permanent link">&para;</a></h3> <p>Обіцянки мають три стани:</p> <ol> <li><strong>Очікує:</strong> Це початковий стан обіцянки перед початком операції</li> <li><strong>Виконано:</strong> Цей стан означає, що вказана операція була завершена.</li> <li><strong>Відхилено:</strong> Цей стан вказує на те, що операція не була виконана. У цьому випадку буде викинуто значення помилки.</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=54-callback-function>54. Що таке зворотний виклик (callback function)<a class=headerlink href=#54-callback-function title="Permanent link">&para;</a></h3> <p>Функція зворотного виклику - це функція, яка передається в іншу функцію як аргумент. Ця функція викликається всередині зовнішньої функції для виконання певної дії. Розглянемо простий приклад використання функції зворотного виклику</p> <pre><code class=language-javascript>function callbackFunction(name) {
  console.log(&quot;Hello &quot; + name);
}

function outerFunction(callback) {
  let name = prompt(&quot;Будь ласка, введіть ваше ім'я.&quot;);
  callback(name);
}

outerFunction(callbackFunction);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=55-callbacks>55. Чому нам потрібні зворотні виклики (callbacks)<a class=headerlink href=#55-callbacks title="Permanent link">&para;</a></h3> <p>Функції зворотного виклику потрібні тому, що javascript - це мова, керована подіями. Це означає, що замість того, щоб чекати на відповідь, javascript буде продовжувати виконання, слухаючи інші події. Розглянемо приклад з першою функцією, яка викликає виклик API (імітований за допомогою setTimeout), і наступною функцією, яка записує повідомлення в журнал.</p> <pre><code class=language-javascript>function firstFunction() {
  // Імітуємо затримку коду
  setTimeout(function () { // Імітуємо затримку коду.
    console.log(&quot;Викликано першу функцію&quot;);
  }, 1000);
}
function secondFunction() {
  console.log(&quot;Викликано другу функцію&quot;);
}
firstFunction();
secondFunction();

Вивести;
// Викликано другу функцію
// Викликана перша функція
</code></pre> <p>Як видно з виводу, javascript не дочекався відповіді першої функції і виконав блок коду, що залишився. Таким чином, функція зворотного виклику використовується для того, щоб переконатися, що певний код не виконується, доки інший код не завершить виконання.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=56-callback-hell>56. Що таке "інферно зворотніх викликів" (callback hell)<a class=headerlink href=#56-callback-hell title="Permanent link">&para;</a></h3> <p>Пекло зворотного виклику - це антипатерн з декількома вкладеними зворотними викликами, який ускладнює читання та налагодження коду при роботі з асинхронною логікою. Пекло зворотних викликів виглядає наступним чином,</p> <pre><code class=language-javascript>async1(function(){
    async2(function(){
        async3(function(){
            async4(function(){
                ....
            });
        });
    });
});
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=57-server-sent-events>57. Що таке події, відправлені з сервера (server-sent events)<a class=headerlink href=#57-server-sent-events title="Permanent link">&para;</a></h3> <p>Події, що надсилаються сервером (SSE) - це технологія server push, яка дозволяє браузеру отримувати автоматичні оновлення від сервера через HTTP-з'єднання, не вдаючись до опитування. Це односторонній канал зв'язку - події передаються лише від сервера до клієнта. Ця технологія використовується в оновленнях Facebook/Twitter, оновленнях біржових котирувань, новинних стрічках тощо.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=58-server-sent-events>58. Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events)<a class=headerlink href=#58-server-sent-events title="Permanent link">&para;</a></h3> <p>Об’єкт EventSource використовується для отримання сповіщень про події, надісланих сервером. Наприклад, ви можете отримувати повідомлення від сервера, як показано нижче:</p> <pre><code class=language-javascript>if (typeof EventSource !== &quot;undefined&quot;) {
  var source = new EventSource(&quot;sse_generator.js&quot;);
  source.onmessage = function (event) {
    document.getElementById(&quot;output&quot;).innerHTML += event.data + &quot;&lt;br&gt;&quot;;
  };
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=59-server-sent-events>59. Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events)<a class=headerlink href=#59-server-sent-events title="Permanent link">&para;</a></h3> <p>Ви можете перевірити підтримку браузером подій, що надсилаються сервером, перед їх використанням, як показано нижче,</p> <pre><code class=language-javascript>if (typeof EventSource !== &quot;undefined&quot;) {
  // Підтримуються події, відправлені сервером. Давайте напишемо код!
} else {
  // Не підтримуються події, що надсилаються сервером
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=60-server-sent-events>60. Які події доступні для подій, відправлених з сервера (server-sent events)<a class=headerlink href=#60-server-sent-events title="Permanent link">&para;</a></h3> <p>Нижче наведено список подій, доступних для подій, що надсилаються сервером</p> <table> <thead> <tr> <th>Подія</th> <th>Опис</th> </tr> </thead> <tbody> <tr> <td>onopen</td> <td>Використовується, коли відкривається з'єднання з сервером</td> </tr> <tr> <td>onmessage</td> <td>Ця подія використовується при отриманні повідомлення</td> </tr> <tr> <td>onerror</td> <td>Відбувається при виникненні помилки</td> </tr> </tbody> </table> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=61-promise>61. Які основні правила обіцянок (promise)<a class=headerlink href=#61-promise title="Permanent link">&para;</a></h3> <p>Обіцянки (promises) є важливою частиною асинхронного програмування в JavaScript і допомагають у керуванні асинхронним кодом. Основні правила обіцянок включають наступне:</p> <ul> <li> <p><strong>Обіцянка - об'єкт</strong>: Обіцянка - це об'єкт в JavaScript, який представляє асинхронну операцію. Вона може бути в стані "виконується" (pending), "виконано успішно" (fulfilled), або "виконано з помилкою" (rejected).</p> </li> <li> <p><strong>Стан і значення</strong>: Обіцянка має два головних властивості: стан (state) і значення (value). Стан визначає, чи завершилася операція, і як вона завершилася (успішно або з помилкою). Значення містить результат операції або об'єкт помилки.</p> </li> <li> <p><strong>Створення обіцянки</strong>: Обіцянку можна створити за допомогою конструктора <code>Promise</code>. Наприклад:</p> </li> </ul> <pre><code class=language-javascript>const myPromise = new Promise((resolve, reject) =&gt; {
 // Виконати асинхронну операцію
 // Якщо успішно - викликати resolve
 // Якщо з помилкою - викликати reject
});
</code></pre> <ul> <li> <p><strong>then() і catch()</strong>: Об'єкт обіцянки має методи <code>then()</code> і <code>catch()</code>, які використовуються для обробки результату операції або обробки помилок:</p> <ul> <li> <p><code>then()</code> викликається, коли обіцянка виконана успішно. Він приймає функцію з результатом операції.</p> </li> <li> <p><code>catch()</code> викликається, коли обіцянка виконана з помилкою. Він приймає функцію для обробки помилок.</p> </li> </ul> </li> <li> <p><strong>Послідовність then()</strong>: Ви можете викликати метод <code>then()</code> послідовно для обробки різних асинхронних операцій в послідовності. Це називається ланцюжком обіцянок.</p> </li> <li> <p><strong>Повернення обіцянок</strong>: Функції, які виконують асинхронні операції, часто повертають обіцянки, щоб інші частини коду могли обробляти результати.</p> </li> <li> <p><strong>Обробка багатьох обіцянок</strong>: Ви можете використовувати метод <code>Promise.all()</code> для обробки декількох обіцянок одночасно і очікування їх всіх перед продовженням виконання коду.</p> </li> <li> <p><strong>Обробка першої завершеної обіцянки</strong>: <code>Promise.race()</code> дозволяє обробляти результат першої завершеної обіцянки з набору обіцянок.</p> </li> <li> <p><strong>Обіцянки та async/await</strong>: Обіцянки часто використовуються разом з ключовим словом <code>async</code> і <code>await</code> для структурування асинхронного коду більш читабельно і зручно.</p> </li> </ul> <p>Ці правила допомагають вам працювати з обіцянками в JavaScript ефективно і безпечно при роботі з асинхронним кодом.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=62-callback-in-callback>62. Що таке зворотній виклик у зворотньому виклику (callback in callback)<a class=headerlink href=#62-callback-in-callback title="Permanent link">&para;</a></h3> <p>Ви можете вкласти один колбек в інший колбек, щоб виконати дії послідовно один за одним. Це називається зворотний виклик у зворотному виклику.</p> <pre><code class=language-javascript>loadScript(&quot;/script1.js&quot;, function (script) {
  console.log(&quot;завантажено перший скрипт&quot;);

  loadScript(&quot;/script2.js&quot;, function (script) {
    console.log(&quot;завантажено другий скрипт&quot;);

    loadScript(&quot;/script3.js&quot;, функція (скрипт) {
      console.log(&quot;завантажено третій скрипт&quot;);
      // після завантаження всіх скриптів
    });
  });
});
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=63-promise-chaining>63. Що таке ланцюг обіцянок (promise chaining)<a class=headerlink href=#63-promise-chaining title="Permanent link">&para;</a></h3> <p>Процес виконання послідовності асинхронних завдань одне за одним з використанням обіцянок називається ланцюжком обіцянок (Promise chaining). Розглянемо приклад ланцюжка обіцянок для обчислення кінцевого результату,</p> <pre><code class=language-javascript>new Promise(function (resolve, reject) {
  setTimeout(() =&gt; resolve(1), 1000);
})
  .then(function (result) {
    console.log(result); // 1
    return result * 2;
  })
  .then(function (result) {
    console.log(result); // 2
    return result * 3;
  })
  .then(function (result) {
    console.log(result); // 6
    return result * 4;
  });
</code></pre> <p>У вищенаведених обробниках результат передається в ланцюжок обробників .then() з наведеним нижче алгоритмом роботи,</p> <ol> <li>Початкова обіцянка виконується за 1 секунду,</li> <li>Після цього викликається обробник <code>.then</code>, який записує результат(1) і повертає обіцянку зі значенням result * 2.</li> <li>Після цього значення передається наступному обробнику <code>.then</code>, який записує result(2) і повертає обіцянку зі значенням result * 3.</li> <li>Нарешті, значення передається останньому обробнику <code>.then</code>, який записує результат(6) і повертає обіцянку з результатом * 4.</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=64-promiseall>64. Що таке promise.all<a class=headerlink href=#64-promiseall title="Permanent link">&para;</a></h3> <p>Promise.all - це обіцянка, яка отримує на вхід масив обіцянок (ітерабельний масив) і повертає результат, коли виконано всі обіцянки або відхилено будь-яку з них. Наприклад, синтаксис методу promise.all наведено нижче,</p> <pre><code class=language-javascript>Promise.all([Promise1, Promise2, Promise3]) .then(result) =&gt; { console.log(result) }) .catch(error =&gt; console.log(`Помилка в обіцянках ${error}`))
</code></pre> <p><strong>Примітка:</strong> Пам'ятайте, що порядок обіцянок (виведення результату) зберігається відповідно до порядку введення.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=65-race-promise>65. Яка мета методу race у обіцянок (promise)<a class=headerlink href=#65-race-promise title="Permanent link">&para;</a></h3> <p>Метод promise.race() повертає екземпляр обіцянки, який першим буде вирішено або відхилено. Розглянемо приклад методу race(), в якому першим обробляється promise2</p> <pre><code class=language-javascript>var promise1 = new Promise(function (resolve, reject) {
  setTimeout(resolve, 500, &quot;one&quot;);
});
var promise2 = new Promise(function (resolve, reject) {
  setTimeout(resolve, 100, &quot;two&quot;);
});

Promise.race([promise1, promise2]).then(function (value) {
  console.log(value); // &quot;two&quot; // Обидві обіцянки вирішаться, але promise2 швидше
});
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=66-javascript-strict-mode>66. Що таке строгий режим у JavaScript (strict mode)<a class=headerlink href=#66-javascript-strict-mode title="Permanent link">&para;</a></h3> <p>Суворий режим - це нова функція в ECMAScript 5, яка дозволяє помістити програму або функцію в "суворий" робочий контекст. Таким чином, він запобігає виконанню певних дій і генерує більше винятків. Буквальний вираз <code>"use strict";</code> вказує браузеру використовувати код javascript в строгому режимі.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=67-strict-mode>67. Чому вам потрібен строгий режим (strict mode)<a class=headerlink href=#67-strict-mode title="Permanent link">&para;</a></h3> <p>Суворий режим корисний для написання "безпечного" JavaScript, перетворюючи "поганий синтаксис" на реальні помилки. Наприклад, він усуває випадкове створення глобальної змінної, видаючи помилку, а також видає помилку при присвоюванні властивості, яку не можна записати, властивості, доступної лише для отримання, неіснуючої властивості, неіснуючої змінної або неіснуючого об'єкта.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=68-strict-mode>68. Як ви оголошуєте строгий режим (strict mode)<a class=headerlink href=#68-strict-mode title="Permanent link">&para;</a></h3> <p>Строгий режим оголошується додаванням "use strict"; на початку скрипту або функції. Якщо його оголошено на початку скрипта, він має глобальну область видимості.</p> <pre><code class=language-javascript>&quot;use strict&quot;;
x = 3.14; // Це призведе до помилки, оскільки x не оголошено
</code></pre> <p>а якщо оголосити всередині функції, то вона має локальну область видимості</p> <pre><code class=language-javascript>x = 3.14; // Це не викличе помилки.
myFunction();

function myFunction() {
  &quot;use strict&quot;;
  y = 3.14; // Це викличе помилку
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=69-double-exclamation>69. Яка мета подвійного оклику (!!) (double exclamation)<a class=headerlink href=#69-double-exclamation title="Permanent link">&para;</a></h3> <p>Виклик double або заперечення(!!) гарантує, що результуючий тип буде логічним. Якщо він був хибним (наприклад, 0, null, undefined і т.д.), він буде хибним, в іншому випадку - істинним. Наприклад, ви можете перевірити версію IE, використовуючи цей вираз, як показано нижче,</p> <pre><code class=language-javascript>let isIE8 = false;
isIE8 = !! navigator.userAgent.match(/MSIE 8.0/);
console.log(isIE8); // повертає true або false
</code></pre> <p>Якщо ви не використовуєте цей вираз, то він повертає початкове значення.</p> <pre><code class=language-javascript>console.log(navigator.userAgent.match(/MSIE 8.0/)); // повертає масив або null
</code></pre> <p><strong>Примітка:</strong> Вираз !! не є оператором, але це просто двічі оператор !</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=70-delete>70. Яка мета оператора delete<a class=headerlink href=#70-delete title="Permanent link">&para;</a></h3> <p>Ключове слово delete використовується для видалення властивості та її значення.</p> <pre><code class=language-javascript>var user = { name: &quot;John&quot;, age: 20 };
delete user.age;

console.log(user); // {name: &quot;John&quot;}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=71-typeof>71. Який оператор typeof<a class=headerlink href=#71-typeof title="Permanent link">&para;</a></h3> <p>Ви можете використовувати оператор typeof для визначення типу змінної JavaScript. Він повертає тип змінної або виразу.</p> <pre><code class=language-javascript>typeof &quot;John Abraham&quot;; // Повертає &quot;рядок&quot;
typeof (1 + 2); // Повертає &quot;число&quot;
typeof [1, 2, 3] // Повертає &quot;об'єкт&quot;, оскільки всі масиви також є об'єктами
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=72-undefined>72. Що таке властивість undefined<a class=headerlink href=#72-undefined title="Permanent link">&para;</a></h3> <p>Властивість undefined вказує на те, що змінній не присвоєно значення, або вона оголошена, але не ініціалізована взагалі. Тип невизначеного значення також є невизначеним.</p> <pre><code class=language-javascript>var user; // Значення не визначено, тип не визначено
console.log(typeof user); //невизначено
</code></pre> <p>Будь-яку змінну можна очистити, встановивши їй значення undefined.</p> <pre><code class=language-javascript>user = undefined;
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=73-null>73. Що таке значення null<a class=headerlink href=#73-null title="Permanent link">&para;</a></h3> <p>Значення null означає навмисну відсутність будь-якого значення об'єкта. Це одне з примітивних значень JavaScript. Тип нульового значення - об'єкт. Ви можете очистити змінну, встановивши значення null.</p> <pre><code class=language-javascript>var user = null;
console.log(typeof user); //об'єкт
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=74-null-undefined>74. Яка різниця між значенням null та undefined<a class=headerlink href=#74-null-undefined title="Permanent link">&para;</a></h3> <p>Нижче наведено основні відмінності між null та undefined,</p> <table> <thead> <tr> <th>Null</th> <th>Undefined</th> </tr> </thead> <tbody> <tr> <td>Це значення присвоєння, яке вказує на те, що змінна вказує на об'єкт, на який немає об'єкта.</td> <td>Це не значення присвоєння, коли змінна оголошена, але їй ще не присвоєно значення.</td> </tr> <tr> <td>Тип null - об'єкт</td> <td>Тип undefined - undefined</td> </tr> <tr> <td>Значення null - це примітивне значення, що представляє нульове, порожнє або неіснуюче посилання. Значення undefined - це примітивне значення, що використовується, коли змінній ще не присвоєно значення.</td> <td>Невизначене значення - це примітивне значення, яке використовується, коли змінній не присвоєно значення.</td> </tr> <tr> <td>Вказує на відсутність значення для змінної</td> <td>Вказує на відсутність самої змінної</td> </tr> <tr> <td>Перетворено в нуль (0) під час виконання примітивних операцій</td> <td>Перетворено в NaN під час виконання примітивних операцій</td> </tr> </tbody> </table> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=75-eval>75. Що таке функція eval<a class=headerlink href=#75-eval title="Permanent link">&para;</a></h3> <p>Функція eval() обчислює JavaScript-код, представлений у вигляді рядка. Рядок може бути виразом JavaScript, змінною, оператором або послідовністю операторів.</p> <pre><code class=language-javascript>console.log(eval(&quot;1 + 2&quot;)); // 3
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=76-window-document>76. Яка різниця між об'єктом window та document<a class=headerlink href=#76-window-document title="Permanent link">&para;</a></h3> <p>Нижче наведено основні відмінності між вікном і документом,</p> <table> <thead> <tr> <th>Вікно</th> <th>Документ</th> </tr> </thead> <tbody> <tr> <td>Це елемент кореневого рівня на будь-якій веб-сторінці</td> <td>Він є прямим дочірнім елементом віконного об'єкта. Це також відоме як модель об'єктів документа (DOM)</td> </tr> <tr> <td>За замовчуванням об'єкт window доступний неявно на сторінці</td> <td>Ви можете отримати до нього доступ за допомогою window.document або document.</td> </tr> <tr> <td>Він має такі методи, як alert(), confirm(), і такі властивості, як document, location</td> <td>Він надає такі методи, як getElementById, getElementsByTagName, createElement тощо</td> </tr> </tbody> </table> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=77-javascript>77. Як ви отримуєте доступ до історії у JavaScript<a class=headerlink href=#77-javascript title="Permanent link">&para;</a></h3> <p>Об'єкт window.history містить історію браузера. Ви можете завантажити попередні та наступні URL-адреси в історії за допомогою методів back() та next().</p> <pre><code class=language-javascript>function goBack() {
  window.history.back();
}
function goForward() {
  window.history.forward();
}
</code></pre> <p><strong>Примітка:</strong> Ви також можете отримати доступ до історії без префікса window.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=78-caps-lock>78. Як ви визначаєте, чи включена клавіша Caps Lock, чи ні<a class=headerlink href=#78-caps-lock title="Permanent link">&para;</a></h3> <p>Подія <code>mouseEvent getModifierState()</code> використовується для повернення булевого значення, яке вказує, чи активовано вказану клавішу-модифікатор, чи ні. Такі модифікатори, як CapsLock, ScrollLock і NumLock активуються при натисканні на них, і деактивуються при повторному натисканні.</p> <p>Розглянемо на прикладі вхідного елемента, щоб визначити поведінку ввімкненого/вимкненого CapsLock,</p> <pre><code class=language-html>&lt;input type=&quot;password&quot; onmousedown=&quot;enterInput(event)&quot; /&gt;

&lt;p id=&quot;feedback&quot;&gt;&lt;/p&gt;

&lt;script&gt;
  function enterInput(e) {
    var flag = e.getModifierState(&quot;CapsLock&quot;);
    if (flag) {
      document.getElementById(&quot;feedback&quot;).innerHTML = &quot;CapsLock активовано&quot;;
    } else {
      document.getElementById(&quot;feedback&quot;).innerHTML =
        &quot;CapsLock не активовано&quot;;
    }
  }
&lt;/script&gt;
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=79-isnan>79. Що таке функція isNaN<a class=headerlink href=#79-isnan title="Permanent link">&para;</a></h3> <p>Функція isNaN() використовується для визначення того, чи є значення недопустимим числом (Not-a-Number) чи ні. Тобто, ця функція повертає true, якщо значення дорівнює NaN. В іншому випадку повертається false.</p> <pre><code class=language-javascript>isNaN(&quot;Hello&quot;); //істина
isNaN(&quot;100&quot;); //false
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=80-undefined>80. Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined<a class=headerlink href=#80-undefined title="Permanent link">&para;</a></h3> <p>Нижче наведено основні відмінності між неоголошеними (не визначеними) та невизначеними змінними,</p> <table> <thead> <tr> <th>undeclared</th> <th>undefined</th> </tr> </thead> <tbody> <tr> <td>Ці змінні не існують у програмі і не оголошені</td> <td>Ці змінні оголошені у програмі, але їм не присвоєно жодного значення</td> </tr> <tr> <td>При спробі прочитати значення неоголошеної змінної виникає помилка виконання програми</td> <td>При спробі прочитати значення невизначеної змінної повертається невизначене значення.</td> </tr> </tbody> </table> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=81>81. Що таке глобальні змінні<a class=headerlink href=#81 title="Permanent link">&para;</a></h3> <p>Глобальні змінні - це змінні, які доступні по всьому коду без обмеження області видимості. Для оголошення локальної змінної використовується ключове слово var, але якщо його опустити, то вона стане глобальною змінною</p> <pre><code class=language-javascript>msg = &quot;Hello&quot;; // var пропущено, вона стає глобальною змінною
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=82>82. Які проблеми із глобальними змінними<a class=headerlink href=#82 title="Permanent link">&para;</a></h3> <p>Проблема глобальних змінних полягає у конфлікті імен змінних локальної та глобальної області видимості. Також складно налагоджувати і тестувати код, який використовує глобальні змінні.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=83-nan>83. Що таке властивість NaN<a class=headerlink href=#83-nan title="Permanent link">&para;</a></h3> <p>Властивість NaN - це глобальна властивість, яка представляє значення "Не-число", тобто вказує на те, що значення не є дійсним числом. Дуже рідко використовують NaN у програмі, але його можна використовувати як значення, що повертається, у кількох випадках</p> <pre><code class=language-javascript>Math.sqrt(-1);
parseInt(&quot;Hello&quot;);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=84-isfinite>84. Яка мета функції isFinite<a class=headerlink href=#84-isfinite title="Permanent link">&para;</a></h3> <p>Функція isFinite() використовується для визначення того, чи є число скінченним, законним числом. Вона повертає false, якщо значення +нескінченність, -нескінченність або NaN (Not-a-Number), інакше повертає true.</p> <pre><code class=language-javascript>isFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(100); // true
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=85-event-flow>85. Що таке потік подій (event flow)<a class=headerlink href=#85-event-flow title="Permanent link">&para;</a></h3> <p>Потік подій - це порядок надходження подій на веб-сторінку. Коли ви клацаєте елемент, вкладений в інші елементи, перш ніж ваш клік досягне місця призначення або цільового елемента, він повинен викликати подію кліку для кожного з його батьківських елементів, починаючи зверху з глобального об'єкта вікна. Існує два способи проходження події</p> <ol> <li>Зверху вниз (перехоплення події)</li> <li>Знизу догори (бульбашковий потік подій)</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=86-event-bubbling>86. Що таке всплиття подій (event bubbling)<a class=headerlink href=#86-event-bubbling title="Permanent link">&para;</a></h3> <p>Розповсюдження подій - це тип поширення подій, коли подія спочатку спрацьовує на внутрішньому цільовому елементі, а потім послідовно спрацьовує на предках (батьках) цільового елемента в тій самій ієрархії вкладеності, доки не досягне зовнішнього DOM-елемента.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=87-event-capturing>87. Що таке захоплення подій (event capturing)<a class=headerlink href=#87-event-capturing title="Permanent link">&para;</a></h3> <p>Захоплення події - це тип поширення події, коли подія спочатку захоплюється зовнішнім елементом, а потім послідовно спрацьовує на нащадках (дочірніх елементах) цільового елемента в тій самій ієрархії вкладеності, доки не досягне найпотаємнішого елемента DOM.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=88-javascript>88. Як ви відправляєте форму за допомогою JavaScript<a class=headerlink href=#88-javascript title="Permanent link">&para;</a></h3> <p>Ви можете відправити форму за допомогою <code>document.forms[0].submit()</code>. Вся інформація з форми надсилається за допомогою обробника події onsubmit</p> <pre><code class=language-javascript>function submit() {
  document.forms[0].submit();
}
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=89>89. Як ви знаходите деталі операційної системи<a class=headerlink href=#89 title="Permanent link">&para;</a></h3> <p>Об'єкт window.navigator містить інформацію про особливості операційної системи браузера відвідувача. Деякі з властивостей операційної системи доступні у розділі властивостей платформи,</p> <pre><code class=language-javascript>console.log(navigator.platform);
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=90-document-load-domcontentloaded>90. Яка різниця між подіями document load та DOMContentLoaded<a class=headerlink href=#90-document-load-domcontentloaded title="Permanent link">&para;</a></h3> <p>Подія <code>DOMContentLoaded</code> спрацьовує, коли початковий HTML-документ повністю завантажено і проаналізовано, не чекаючи на завершення завантаження ресурсів (таблиць стилів, зображень і підкадрів). Тоді як подія load спрацьовує, коли завантажується вся сторінка, включаючи всі залежні ресурси (таблиці стилів, зображення).</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=91-native-host-user>91. Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами<a class=headerlink href=#91-native-host-user title="Permanent link">&para;</a></h3> <p>"Нативні об'єкти" - це об'єкти, які є частиною мови JavaScript, визначені специфікацією ECMAScript. Наприклад, String, Math, RegExp, Object, Function та інші основні об'єкти, визначені в специфікації ECMAScript. "Хост-об'єкти" - це об'єкти, що надаються браузером або середовищем виконання (Node). Наприклад, вікно, XmlHttpRequest, DOM-вузли тощо вважаються хост-об'єктами. Користувацькі об'єкти - це об'єкти, визначені в javascript-коді. Наприклад, об'єкти User, створені для інформації про профіль.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=92-javascript>92. Які інструменти або техніки використовуються для відлагодження коду JavaScript<a class=headerlink href=#92-javascript title="Permanent link">&para;</a></h3> <p>Для налагодження JavaScript можна використовувати наступні інструменти або методи</p> <ol> <li>Chrome Devtools</li> <li>оператор відладчика</li> <li>Старий добрий оператор console.log</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=93-promises-callbacks>93. Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks)<a class=headerlink href=#93-promises-callbacks title="Permanent link">&para;</a></h3> <p>Нижче наведено перелік переваг та недоліків обіцянок над зворотними викликами,</p> <p><strong>Плюси:</strong></p> <ol> <li>Це дозволяє уникнути пекла зворотних дзвінків, які неможливо прочитати</li> <li>Легко писати послідовний асинхронний код з .then()</li> <li>Легко писати паралельний асинхронний код з Promise.all()</li> <li>Вирішує деякі з поширених проблем зворотного виклику (виклик занадто пізно, занадто рано, багато разів і ковтання помилок/винятків)</li> </ol> <p><strong>Можливі недоліки</strong></p> <ol> <li>Мало складного коду</li> <li>Потрібно завантажувати поліфіл, якщо ES6 не підтримується</li> </ol> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=94-property>94. Яка різниця між атрибутом та властивістю (property)<a class=headerlink href=#94-property title="Permanent link">&para;</a></h3> <p>Атрибути визначаються в HTML-розмітці, тоді як властивості визначаються в DOM. Наприклад, наведений нижче HTML-елемент має 2 атрибути type і value,</p> <pre><code class=language-javascript>&lt;input type=&quot;text&quot; value=&quot;Name:&quot;&gt;
</code></pre> <p>Ви можете отримати значення атрибута, як показано нижче,</p> <pre><code class=language-javascript>const input = document.querySelector(&quot;input&quot;);
console.log(input.getAttribute(&quot;value&quot;)); // Доброго ранку
console.log(input.value); // Good morning
</code></pre> <p>And after you change the value of the text field to "Good evening", it becomes like</p> <pre><code class=language-javascript>console.log(input.getAttribute(&quot;value&quot;)); // Good evening
console.log(input.value); // Good evening
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=95-same-origin-policy>95. Що таке політика однакового походження (same-origin policy)<a class=headerlink href=#95-same-origin-policy title="Permanent link">&para;</a></h3> <p>Політика однакового походження - це політика, яка не дозволяє JavaScript робити запити через межі домену. Походження визначається як комбінація схеми URI, імені хоста і номера порту. Якщо ви ввімкнете цю політику, вона не дозволить шкідливому скрипту на одній сторінці отримати доступ до конфіденційних даних на іншій веб-сторінці за допомогою моделі об'єктів документа (DOM).</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=96-void-0>96. Яка мета фрази void 0<a class=headerlink href=#96-void-0 title="Permanent link">&para;</a></h3> <p>Void(0) is used to prevent the page from refreshing. This will be helpful to eliminate the unwanted side-effect, because it will return the undefined primitive value. It is commonly used for HTML documents that use href="JavaScript:Void(0);" within an <code>&lt;a&gt;</code> element. i.e, when you click a link, the browser loads a new page or refreshes the same page. But this behavior will be prevented using this expression. For example, the below link notify the message without reloading the page</p> <pre><code class=language-javascript>&lt;a href=&quot;JavaScript:void(0);&quot; onclick=&quot;alert('Well done!')&quot;&gt;
  Click Me!
&lt;/a&gt;
</code></pre> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=97-javascript>97. Чи є JavaScript компільованою чи інтерпретованою мовою<a class=headerlink href=#97-javascript title="Permanent link">&para;</a></h3> <p>JavaScript - это интерпретируемый, а не компилируемый язык. Интерпретатор в браузере считывает код JavaScript, интерпретирует каждую строку и запускает его на выполнение. В настоящее время в современных браузерах используется технология Just-In-Time (JIT) компиляции, которая компилирует JavaScript в исполняемый байт-код непосредственно в момент его запуска.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=98-javascript>98. Чи є JavaScript чутливою до регістру мовою<a class=headerlink href=#98-javascript title="Permanent link">&para;</a></h3> <p>Так, JavaScript - це мова, чутлива до регістру. Ключові слова мови, змінні, назви функцій та об'єктів, а також будь-які інші ідентифікатори завжди повинні вводитися з великої літери.</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=99-java-javascript>99. Чи існує якась зв'язок між Java та JavaScript<a class=headerlink href=#99-java-javascript title="Permanent link">&para;</a></h3> <p>Ні, це абсолютно різні мови програмування і не мають нічого спільного між собою. Але обидві вони є об'єктно-орієнтованими мовами програмування і, як і багато інших мов, мають схожий синтаксис для основних функцій (if, else, for, switch, break, continue і т.д.).</p> <p><a href=#3-javascript>Back to top ⬆️</a></p> <h3 id=100-events>100. Що таке події (events)<a class=headerlink href=#100-events title="Permanent link">&para;</a></h3> <p>Події - це "речі", які відбуваються з елементами HTML. Коли JavaScript використовується на HTML-сторінках, він може "реагувати" на ці події. Ось деякі приклади подій HTML,</p> <ol> <li>Веб-сторінка завершила завантаження</li> <li>Змінено поле введення</li> <li>Кнопка була натиснута</li> </ol> <p>Опишемо поведінку події кліку для елемента button,</p> <pre><code class=language-javascript> &lt;!doctype html&gt;
 &lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      function greeting() {
        alert('Hello! Good morning');
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;greeting()&quot;&gt;Click me&lt;/button&gt;
  &lt;/body&gt;
 &lt;/html&gt;
</code></pre> </article> </div> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg> Back to top </button> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=git.html class="md-footer__link md-footer__link--prev" aria-label="Previous: GIT" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> Previous </span> <div class=md-ellipsis> GIT </div> </div> </a> <a href=java.html class="md-footer__link md-footer__link--next" aria-label="Next: Java" rel=next> <div class=md-footer__title> <span class=md-footer__direction> Next </span> <div class=md-ellipsis> Java </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2014 - 2023 TJHelpers </div> </div> <div class=md-social> <a href=https://github.com/tendil/ target=_blank rel=noopener title=github.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> <a href=https://t.me/XllrepoDewelloper target=_blank rel=noopener title=t.me class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M248 8C111.033 8 0 119.033 0 256s111.033 248 248 248 248-111.033 248-248S384.967 8 248 8Zm114.952 168.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.452 10.452 0 0 1 3.53 6.716 43.765 43.765 0 0 1 .417 9.769Z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <div class=md-consent data-md-component=consent id=__consent hidden> <div class=md-consent__overlay></div> <aside class=md-consent__inner> <form class="md-consent__form md-grid md-typeset" name=consent> <h4>Cookie consent</h4> <p>We use cookies to recognize your repeated visits and preferences, as well as to measure the effectiveness of our documentation and whether users find what they're searching for. With your consent, you're helping us to make our documentation better.</p> <input class=md-toggle type=checkbox id=__settings> <div class=md-consent__settings> <ul class=task-list> <li class=task-list-item> <label class=task-list-control> <input type=checkbox name=github checked> <span class=task-list-indicator></span> GitHub </label> </li> </ul> </div> <div class=md-consent__controls> <button class="md-button md-button--primary">Accept</button> <label class=md-button for=__settings>Manage settings</label> </div> </form> </aside> </div> <script>var consent=__md_get("__consent");if(consent)for(var input of document.forms.consent.elements)input.name&&(input.checked=consent[input.name]||!1);else"file:"!==location.protocol&&setTimeout(function(){document.querySelector("[data-md-component=consent]").hidden=!1},250);var action,form=document.forms.consent;for(action of["submit","reset"])form.addEventListener(action,function(e){if(e.preventDefault(),"reset"===e.type)for(var n of document.forms.consent.elements)n.name&&(n.checked=!1);__md_set("__consent",Object.fromEntries(Array.from(new FormData(form).keys()).map(function(e){return[e,!0]}))),location.hash="",location.reload()})</script> <script id=__config type=application/json>{"base": "..", "features": ["navigation.top", "navigation.footer", "navigation.instant", "navigation.path", "announce.dismiss", "content.action.edit", "content.action.view", "content.code.annotate", "content.code.copy", "search.suggest", "search.highlight", "search.share"], "search": "../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=../assets/javascripts/bundle.dff1b7c8.min.js></script> </body> </html>