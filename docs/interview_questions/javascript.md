## **3. Запитання для співбесіди на тему JavaScript**

---

| №   | Питання                                                                                                                                 |
|-----|-----------------------------------------------------------------------------------------------------------------------------------------|
| 1   | [Які існують способи створення об'єктів у JavaScript](#1-javascript)                                                                    |
| 2   | [Що таке ланцюг прототипів](#2)                                                                                                         |
| 3   | [В чому різниця між методами Call, Apply та Bind](#3-call-apply-bind)                                                                   |
| 4   | [Що таке JSON та його загальні операції](#4-json)                                                                                       |
| 5   | [Яка мета методу slice для масиву](#5-slice)                                                                                            |
| 6   | [Яка мета методу splice для масиву](#6-splice)                                                                                          |
| 7   | [В чому різниця між slice та splice](#7-slice-splice)                                                                                   |
| 8   | [Як порівняти Об'єкт із Map](#8-map)                                                                                                    |
| 9   | [В чому різниця між операторами == та ===](#9)                                                                                          |
| 10  | [Що таке лямбда- або стрілкові функції](#10-)                                                                                           |
| 11  | [Що таке функція першого класу](#11)                                                                                                    |
| 12  | [Що таке функція першого порядку](#12)                                                                                                  |
| 13  | [Що таке функція вищого порядку](#13)                                                                                                   |
| 14  | [Що таке унарна функція](#14)                                                                                                           |
| 15  | [Що таке функція каррінг](#15)                                                                                                          |
| 16  | [Що таке чиста функція](#16)                                                                                                            |
| 17  | [Яка мета ключового слова let](#17-let)                                                                                                 |
| 18  | [В чому різниця між let та var](#18-let-var)                                                                                            |
| 19  | [Яка причина вибору назви let як ключового слова](#19-let)                                                                              |
| 20  | [Як перевизначити змінні в switch блоку без помилки](#20-switch)                                                                        |
| 21  | [Що таке Тимчасова мертва зона](#21)                                                                                                    |
| 22  | [Що таке Негайно Викликані Функціональні Вирази (IIFE)](#22-iife)                                                                       |
| 23  | [Як декодувати або закодувати URL в JavaScript?](#23-url-javascript)                                                                    |
| 24  | [Що таке мемоізація](#24)                                                                                                               |
| 25  | [Що таке Хойстінг](#25)                                                                                                                 |
| 26  | [Що таке класи в ES6](#26-es6)                                                                                                          |
| 27  | [Що таке замикання](#27)                                                                                                                |
| 28  | [Що таке модулі](#28)                                                                                                                   |
| 29  | [Чому вам потрібні модулі](#29)                                                                                                         |
| 30  | [Що таке область видимості в JavaScript](#30-javascript)                                                                                |
| 31  | [Що таке сервісний працівник (service worker)](#31-service-worker)                                                                      |
| 32  | [Як ви змінюєте DOM, використовуючи сервісний працівник (service worker)](#32-dom-service-worker)                                       |
| 33  | [Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker)](#33-service-worker)                    |
| 34  | [Що таке IndexedDB](#34-indexeddb)                                                                                                      |
| 35  | [Що таке веб-сховище (web storage)](#35-web-storage)                                                                                    |
| 36  | [Що таке пост-повідомлення (post message)](#36-post-message)                                                                            |
| 37  | [Що таке кука (cookie)](#37-cookie)                                                                                                     |
| 38  | [Чому вам потрібна кука (cookie)](#38-cookie)                                                                                           |
| 39  | [Які параметри куки (cookie)](#39-cookie)                                                                                               |
| 40  | [Як видаляти куку (cookie)](#40-cookie)                                                                                                 |
| 41  | [Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage)](#41-local-storage-session-storage) |
| 42  | [Яка основна різниця між localStorage та sessionStorage](#42-localstorage-sessionstorage)                                               |
| 43  | [Як отримати доступ до веб-сховища (web storage)](#43-web-storage)                                                                      |
| 44  | [Які методи доступні для сеансового сховища (session storage)](#44-session-storage)                                                     |
| 45  | [Що таке подія сховища (storage event) та його обробник події (event handler)](#45-storage-event-event-handler)                         |
| 46  | [Чому вам потрібне веб-сховище (web storage)](#46-web-storage)                                                                          |
| 47  | [Як перевірити підтримку веб-сховища браузером (browser support)](#47-browser-support)                                                  |
| 48  | [Як перевірити підтримку веб-працівників браузером (browser support)](#48-browser-support)                                              |
| 49  | [Надайте приклад веб-працівника (web worker)](#49-web-worker)                                                                           |
| 50  | [Які обмеження веб-працівників на DOM](#50-dom)                                                                                         |
| 51  | [Що таке обіцянка (promise)](#51-promise)                                                                                               |
| 52  | [Чому вам потрібна обіцянка (promise)](#52-promise)                                                                                     |
| 53  | [Які три стани у обіцянки (promise)](#53-promise)                                                                                       |
| 54  | [Що таке зворотний виклик (callback function)](#54-callback-function)                                                                   |
| 55  | [Чому нам потрібні зворотні виклики (callbacks)](#55-callbacks)                                                                         |
| 56  | [Що таке "інферно зворотніх викликів" (callback hell)](#56-callback-hell)                                                               |
| 57  | [Що таке події, відправлені з сервера (server-sent events)](#57-server-sent-events)                                                     |
| 58  | [Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events)](#58-server-sent-events)                               |
| 59  | [Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events)](#59-server-sent-events)                      |
| 60  | [Які події доступні для подій, відправлених з сервера (server-sent events)](#60-server-sent-events)                                     |
| 61  | [Які основні правила обіцянок (promise)](#61-promise)                                                                                   |                                                                                                                                                                                                             |
| 62  | [Що таке зворотній виклик у зворотньому виклику (callback in callback)](#62-callback-in-callback)                                       |
| 63  | [Що таке ланцюг обіцянок (promise chaining)](#63-promise-chaining)                                                                      |
| 64  | [Що таке promise.all](#64-promiseall)                                                                                                   |
| 65  | [Яка мета методу race у обіцянок (promise)](#65-race-promise)                                                                           |
| 66  | [Що таке строгий режим у JavaScript (strict mode)](#66-javascript-strict-mode)                                                          |
| 67  | [Чому вам потрібен строгий режим (strict mode)](#67-strict-mode)                                                                        |
| 68  | [Як ви оголошуєте строгий режим (strict mode)](#68-strict-mode)                                                                         |
| 69  | [Яка мета подвійного оклику (!!) (double exclamation)](#69-double-exclamation)                                                          |
| 70  | [Яка мета оператора delete](#70-delete)                                                                                                 |
| 71  | [Який оператор typeof](#71-typeof)                                                                                                      |
| 72  | [Що таке властивість undefined](#72-undefined)                                                                                          |
| 73  | [Що таке значення null](#73-null)                                                                                                       |
| 74  | [Яка різниця між значенням null та undefined](#74-null-undefined)                                                                       |
| 75  | [Що таке функція eval](#75-eval)                                                                                                        |
| 76  | [Яка різниця між об'єктом window та document](#76-window-тdocument)                                                                     |
| 77  | [Як ви отримуєте доступ до історії у JavaScript](#77-javascript)                                                                        |
| 78  | [Як ви визначаєте, чи включена клавіша Caps Lock, чи ні](#78-caps-lock)                                                                 |
| 79  | [Що таке функція isNaN](#79-isnan)                                                                                                      |
| 80  | [Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined](#80-undefined)                                  |
| 81  | [Що таке глобальні змінні](#81)                                                                                                         |
| 82  | [Які проблеми із глобальними змінними](#82)                                                                                             |
| 83  | [Що таке властивість NaN](#83-nan)                                                                                                      |
| 84  | [Яка мета функції isFinite](#84-isfinite)                                                                                               |
| 85  | [Що таке потік подій (event flow)](#85-event-flow)                                                                                      |
| 86  | [Що таке всплиття подій (event bubbling)](#86-event-bubbling)                                                                           |
| 87  | [Що таке захоплення подій (event capturing)](#87-event-capturing)                                                                       |
| 88  | [Як ви відправляєте форму за допомогою JavaScript](#88-javascript)                                                                      |
| 89  | [Як ви знаходите деталі операційної системи](#89)                                                                                       |
| 90  | [Яка різниця між подіями document load та DOMContentLoaded](#90-load-domcontentloaded)                                                  |
| 91  | [Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами](#91-host-user)                        |
| 92  | [Які інструменти або техніки використовуються для відлагодження коду JavaScript](#92-javascript)                                        |
| 93  | [Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks)](#93-promises-callbacks)                    |
| 94  | [Яка різниця між атрибутом та властивістю (property)](#94-property)                                                                     |
| 95  | [Що таке політика однакового походження (same-origin policy)](#95-same-origin-policy)                                                   |
| 96  | [Яка мета фрази void 0](#96-void-0)                                                                                                     |
| 97  | [Чи є JavaScript компільованою чи інтерпретованою мовою](#97-javascript)                                                                |
| 98  | [Чи є JavaScript чутливою до регістру мовою](#98-javascript)                                                                            |
| 99  | [Чи існує якась зв'язок між Java та JavaScript](#99-java-javascript)                                                                    |
| 100 | [Що таке події (events)](#100-events)                                                                                                   |


# Відповіді - 'JavaScript'

[Back to top ⬆️](#3-javascript)
### 1. Які існують способи створення обєктів у JavaScript
Існує багато способів створення об'єктів у javascript, як показано нижче

   1. **Конструктор об'єктів:**

      Найпростіший спосіб створення порожнього об'єкта - використання конструктора об'єктів. Наразі такий підхід не рекомендується.

      ```javascript
      var object = new Object();
      ```

   2. **Метод створення об'єкту Object:**

      Метод create об'єкту Object створює новий об'єкт, передаючи в якості параметру об'єкт-прототип

      ```javascript
      var object = Object.create(null);
      ```

   3. **Синтаксис літералів об'єктів:**

      Синтаксис літералів об'єкта (або ініціалізатор об'єкта) - це відокремлений комами набір пар ім'я-значення, обгорнутий фігурними дужками.

      ```javascript
      var object = {
           name: "Sudheer",
           age: 34
      };

      Значення властивостей об'єктних літералів можуть бути будь-якого типу даних, включаючи масив, функцію та вкладений об'єкт.
      ```

      **Примітка:** Це найпростіший спосіб створення об'єкта

   4. **Конструктор функцій:**

      Створіть будь-яку функцію і застосуйте оператор new для створення екземплярів об'єктів,

      ```javascript
      function Person(name) {
        this.name = name;
        this.age = 21;
      }
      var object = new Person("Sudheer");
      ```

   5. **Конструктор функції з прототипом:**

      Подібно до конструктора функцій, але використовує прототип для їх властивостей та методів,

      ```javascript
      function Person() {}
      Person.prototype.name = "Sudheer";
      var object = new Person();
      ```

      Це еквівалентно створенню екземпляра за допомогою методу створення об'єкта з прототипом функції, а потім виклику цієї функції з екземпляром і параметрами в якості аргументів.

      ```javascript
      function func() {};

      new func(x, y, z);
      ```

      **(АБО)**

      ```javascript
      // Створити новий екземпляр з використанням прототипу функції.
      var newInstance = Object.create(func.prototype)

      // Викликати функцію
      var result = func.call(newInstance, x, y, z),

      // Якщо результат є ненульовим об'єктом, використовуйте його, інакше просто використовуйте новий екземпляр.
      console.log(result && typeof result === 'object' ? result : newInstance);
      ```

   6. **Синтаксис класів у ES6:** *Синтаксис класів у ES6

      У ES6 введено клас для створення об'єктів

      ```javascript
      class Person {
        constructor(name) {
          this.name = name;
        }
      }

      var object = new Person("Sudheer");
      ```

   7. **Шаблон синглетону:**

      Синглтон - це об'єкт, який може бути створений лише один раз. Повторні виклики його конструктора повертають той самий екземпляр, і таким чином можна гарантувати, що випадково не буде створено декілька екземплярів.

      ```javascript
      var object = new (function () {
        this.name = "Sudheer";
      })();
      ```

[Back to top ⬆️](#3-javascript)
### 2. Що таке ланцюг прототипів
**Ланцюжок прототипів** використовується для створення нових типів об'єктів на основі існуючих. Це схоже на успадкування у мовах, заснованих на класах.

   Прототип на екземплярі об'єкта доступний через **Object.getPrototypeOf(object)** або властивість **\_\_proto__**, тоді як прототип на функції конструктора доступний через **Object.prototype**.

   ![Скріншот](images/prototype_chain.png)

[Back to top ⬆️](#3-javascript)
### 3. В чому різниця між методами Call, Apply та Bind

   Різницю між методами Call, Apply та Bind можна пояснити за допомогою наступних прикладів,

   **Виклик:** Метод call() викликає функцію із заданим значенням `this` і аргументами, що надаються один за одним

   ```javascript
   var employee1 = { firstName: "John", lastName: "Rodson" };
   var employee2 = { firstName: "Jimmy", lastName: "Baily" };

   function invite(greeting1, greeting2) {
     console.log(
       greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
     );
   }

   invite.call(employee1, "Hello", "How are you?"); // Привіт Джон Родсон, як справи?
   invite.call(employee2, "Hello", "How are you?"); // Привіт Джиммі Бейлі, як справи?
   ```

   **Apply:** Викликає функцію з заданим значенням `this` і дозволяє передавати аргументи у вигляді масиву

   ```javascript
   var employee1 = { firstName: "John", lastName: "Rodson" };
   var employee2 = { firstName: "Jimmy", lastName: "Baily" };

   function invite(greeting1, greeting2) {
     console.log(
       greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
     );
   }

   invite.apply(employee1, ["Hello", "How are you?"]); // Привіт Джон Родсон, як справи?
   invite.apply(employee2, ["Hello", "How are you?"]); // Привіт Джиммі Бейлі, як справи?
   ```

   **bind:** повертає нову функцію, що дозволяє передавати будь-яку кількість аргументів

   ```javascript
   var employee1 = { firstName: "John", lastName: "Rodson" };
   var employee2 = { firstName: "Jimmy", lastName: "Baily" };

   function invite(greeting1, greeting2) {
     console.log(
       greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
     );
   }

   var inviteEmployee1 = invite.bind(employee1);
   var inviteEmployee2 = invite.bind(employee2);
   inviteEmployee1("Hello", "How are you?"); // Привіт Джон Родсон, як справи?
   inviteEmployee2("Hello", "How are you?"); // Привіт, Джиммі Бейлі, як справи?
   ```

   Виклик і застосування практично взаємозамінні. Обидва вони негайно виконують поточну функцію. Вам потрібно вирішити, що простіше - надсилати масив або список аргументів, розділених комами. Ви можете запам'ятати, розглядаючи Call як **comma** (відокремлений список), а Apply як **Array** (масив).

   Тоді як Bind створює нову функцію, яка матиме `this` як перший параметр, переданий до bind().


[Back to top ⬆️](#3-javascript)
### 4. Що таке JSON та його загальні операції
   **JSON** - це текстовий формат даних, що відповідає об'єктному синтаксису JavaScript, який популяризував Дуглас Крокфорд (Douglas Crockford). Він корисний, коли ви хочете передати дані через мережу, і являє собою просто текстовий файл з розширенням .json і MIME-типом application/json.

   **Синтаксичний аналіз:** Перетворення рядка в нативний об'єкт

   ```javascript
   JSON.parse(text);
   ```

   **Структурування:** перетворення нативного об'єкта в рядок для передачі по мережі

   ```javascript
   JSON.stringify(object);
   ```

[Back to top ⬆️](#3-javascript)
### 5. Яка мета методу slice для масиву
   Метод **slice()** повертає вибрані елементи масиву у вигляді нового об'єкта масиву. Він вибирає елементи, починаючи з заданого початкового аргументу, і закінчуючи заданим необов'язковим кінцевим аргументом, не включаючи останній елемент. Якщо ви опустите другий аргумент, то вибірка буде виконуватися до кінця.

   Деякі приклади використання цього методу наведено нижче,

   ```javascript
   let arrayIntegers = [1, 2, 3, 4, 5];
   let arrayIntegers1 = arrayIntegers.slice(0, 2); // повертає [1,2]
   let arrayIntegers2 = arrayIntegers.slice(2, 3); // повертає [3]
   let arrayIntegers3 = arrayIntegers.slice(4); //повертається [5]
   ```

   **Примітка:** Метод slice не мутує оригінальний масив, але повертає підмножину у вигляді нового масиву.

[Back to top ⬆️](#3-javascript)
### 6. Яка мета методу splice для масиву
Метод **splice()** використовується або для додавання/видалення елементів до/з масиву, а потім повертає видалений елемент. Перший аргумент вказує позицію в масиві для вставки або видалення, тоді як необов'язковий другий аргумент вказує кількість елементів, які потрібно видалити. Кожен додатковий аргумент додається до масиву.

Деякі приклади використання цього методу наведено нижче:

```javascript
let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

let arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); // повертає [1, 2]; вихідний масив: [3, 4, 5]
let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // повертає [4, 5]; вихідний масив: [1, 2, 3]
let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); //повертає [4]; вихідний масив: [1, 2, 3, "a", "b", "c", 5]
```

   **Примітка:** Метод Splice модифікує вихідний масив і повертає видалений масив.

[Back to top ⬆️](#3-javascript)
### 7. В чому різниця між slice та splice
Деякі основні відмінності в табличній формі:

   | Slice                                          | Splice |
   |------------------------------------------------| ----------------------------------------------- |
   | Не модифікує вихідний масив (незмінний)        | Модифікує вихідний масив (змінюваний) |
   | Повертає підмножину вихідного масиву           | Повертає видалені елементи як масив |
   | Використовується для вибору елементів з масиву | Використовується для вставки або видалення елементів в/з масиву |

[Back to top ⬆️](#3-javascript)
### 8. Як порівняти Об'єкт із Map
 **Об'єкти** схожі на мапи у тому, що обидва дозволяють встановлювати ключі для значень, отримувати ці значення, видаляти ключі та визначати, чи зберігається щось за ключем. З цієї причини об'єкти історично використовувалися як мапи. Але існують важливі відмінності, які роблять використання мапи кращим у певних випадках.

   1. Ключами об'єкта є рядки та символи, тоді як для мапи вони можуть бути будь-якими значеннями, включаючи функції, об'єкти та будь-які примітиви.
   2. Ключі на карті впорядковані, а ключі, додані до об'єкта, ні. Таким чином, при ітерації над об'єктом Map повертає ключі у порядку їх додавання.
   3. Розмір Map можна легко отримати за допомогою властивості size, в той час як кількість властивостей в Object потрібно визначати вручну.
   4. Мапа є ітерабельним об'єктом і тому може бути безпосередньо ітерабельною, в той час як ітерація над Об'єктом вимагає отримання його ключів та ітерації над ними.
   5. Об'єкт має прототип, тому на карті є ключі за замовчуванням, які можуть зіткнутися з вашими ключами, якщо ви не будете обережними. Починаючи з ES5 це можна обійти за допомогою map = Object.create(null), але це рідко робиться.
   6. Карта може працювати краще у сценаріях, що передбачають часте додавання та видалення пар ключів.

[Back to top ⬆️](#3-javascript)
### 9. В чому різниця між операторами == та ===
JavaScript забезпечує як строге ```(===, !==)```, так і привідне ```(==, !=)``` порівняння на рівність. Строгі оператори беруть до уваги тип змінної, в той час як нестрогі оператори виконують корекцію/перетворення типу на основі значень змінних. Строгі оператори виконують наступні умови для різних типів,

   1. Два рядки є строго рівними, якщо вони мають однакову послідовність символів, однакову довжину і однакові символи у відповідних позиціях.
   2. Два числа є строго рівними, якщо вони є чисельно рівними, тобто мають однакове числове значення.
      Існує два особливих випадки,
      1. NaN не дорівнює ніякому числу, включаючи NaN.
      2. Додатні та від'ємні нулі дорівнюють один одному.
   3. Два булевих операнди строго рівні, якщо обидва істинні або обидва хибні.
   4. Два об'єкти строго рівні, якщо вони посилаються на один і той самий об'єкт.
   5. Типи ```Null та Undefined не рівні з ===, але рівні з ==```, тобто
      ```null === undefined --> false```, але ```null ==u ndefined --> true```

   Декілька прикладів, які охоплюють вищезгадані випадки,

```javascript
0 == false // true
0 === false // false
1 == "1" // true
1 === "1" // false
null == undefined // true
null === undefined // false
'0' == false // true
'0' === false // false
[]==[] або []===[] //false, посилаються на різні об'єкти в пам'яті
{}=={} або {}==={} //неправда, посилаються на різні об'єкти в пам'яті
```

[Back to top ⬆️](#3-javascript)
### 10. Що таке лямбда- або стрілкові функції

Функція-стрілка - це коротший синтаксис виразу функції, який не має власних **this, arguments, super або new.target**.  
Ці функції найкраще підходять для функцій, що не є методами, і їх не можна використовувати як конструктори.


[Back to top ⬆️](#3-javascript)
### 11. Що таке функція першого класу
У Javascript функції є об'єктами першого класу. Першокласні функції означають, що функції в цій мові поводяться так само, як і будь-які інші змінні.

Наприклад, у такій мові функцію можна передавати як аргумент іншим функціям, повертати іншою функцією і присвоювати як значення змінній. Наприклад, у наведеному нижче прикладі функції-оброблювачі, присвоєні слухачеві

```javascript
const handler = () => console.log("Це функція обробки кліку");
document.addEventListener("click", handler);
```


[Back to top ⬆️](#3-javascript)
### 12. Що таке функція першого порядку
Функція першого порядку - це функція, яка не приймає іншу функцію як аргумент і не повертає функцію як своє значення.

```javascript
const firstOrder = () => console.log("Я функція першого порядку!");
```

[Back to top ⬆️](#3-javascript)
### 13. Що таке функція вищого порядку
 Функція вищого порядку - це функція, яка приймає іншу функцію як аргумент або повертає функцію як значення, що повертається, або і те, і інше.

```javascript
const firstOrderFunc = () => ...
  console.log("Привіт, я функція першого порядку");
const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
higherOrder(firstOrderFunc);
```

[Back to top ⬆️](#3-javascript)
### 14. Що таке унарна функція
Унарна функція (тобто монада) - це функція, яка приймає рівно один аргумент. Вона позначає єдиний аргумент, який приймає функція.

Розглянемо приклад унарної функції:

```javascript
const unaryFunction = (a) => console.log(a + 10); // Додати до заданого аргументу 10 і вивести значення
```

[Back to top ⬆️](#3-javascript)
### 15. Що таке функція каррінг

Каррінг - це процес перетворення функції з декількома аргументами на послідовність функцій, кожна з яких має лише один аргумент. Каррінг названо на честь математика **Гаскелла Каррі**. Застосовуючи каррінг, n-арна функція перетворюється на унарну функцію.

Розглянемо приклад n-арної функції і те, як вона перетворюється на функцію каррі,

```javascript
const multiArgFunction = (a, b, c) => a + b + c;
console.log(multiArgFunction(1, 2, 3)); // 6

const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
curryUnaryFunction(1); // повертає функцію: b => c => 1 + b + c
curryUnaryFunction(1)(2); // повертає функцію: c => 3 + c
curryUnaryFunction(1)(2)(3); // повертає число 6
```

Функції каррі чудово підходять для покращення **можливості повторного використання коду** та **функціонального складу**.


[Back to top ⬆️](#3-javascript)
### 16. Що таке чиста функція
 Чиста функція - це функція, значення, що повертається, визначається лише її аргументами без будь-яких побічних ефектів, тобто якщо ви викликаєте функцію з тими самими аргументами "n" разів і "n" місць у програмі, вона завжди повертатиме одне й те саме значення.

Розглянемо на прикладі різницю між чистими і нечистими функціями:

```javascript
//Нечиста
let numberArray = [];
const impureAddNumber = (number) => numberArray.push(number);
//Чистий
const pureAddNumber = (number) => (argNumberArray) => (numberArray)
argNumberArray.concat([number]);

//Вивести результати
console.log(impureAddNumber(6)); // повертає 1
console.log(numberArray); // повертає [6]
console.log(pureAddNumber(7)(numberArray)); // повертає [6, 7]
console.log(numberArray); // повертає [6]
```

Як видно з вищенаведених фрагментів коду, функція **Push** сама є нечистою, оскільки змінює масив і повертає індекс числа, що проштовхується, незалежно від значення параметра. . Тоді як **Concat**, навпаки, бере масив і об'єднує його з іншим масивом, створюючи абсолютно новий масив без побічних ефектів. Крім того, значення, що повертається, є конкатенацією попереднього масиву.

Пам'ятайте, що чисті функції важливі, оскільки вони спрощують модульне тестування без побічних ефектів і не потребують ін'єкції залежностей. Вони також уникають тісного зв'язку і ускладнюють злам вашої програми, оскільки не мають побічних ефектів. Ці принципи поєднуються з концепцією **Immutability** в ES6, надаючи перевагу використанню **const** над **let**.


[Back to top ⬆️](#3-javascript)
### 17. Яка мета ключового слова let
Інструкція `let` оголошує локальну змінну з областю видимості **блоку**. Таким чином, змінні, визначені з ключовим словом let, обмежені в області видимості блоком, оператором або виразом, в якому вони використовуються. Тоді як змінні, оголошені з ключовим словом `var`, використовуються для визначення змінної глобально або локально для всієї функції незалежно від області видимості блоку.

Розглянемо приклад, щоб продемонструвати використання:

```javascript
let counter = 30;
if (counter === 30) {
  let counter = 31;
  console.log(counter); // 31
}
console.log(counter); // 30 (тому що змінної в блоці if тут не буде)
```

[Back to top ⬆️](#3-javascript)
### 18. В чому різниця між let та var

| var                                        | let                         |
|--------------------------------------------| --------------------------- |
| Був доступний з самого початку JavaScript  | Представлений як частина ES6
| Має область видимості функції              | Має область видимості блоку
| Змінні будуть підняті                      | Підняті, але не ініціалізовані

Давайте розглянемо приклад, щоб побачити різницю:
```javascript
function userDetails(user_name) {
  if (user_name) {
    console.log(salary); // невизначено через підняття
    console.log(age); // ReferenceError: Неможливо отримати доступ до 'age' до ініціалізації
    let age = 30;
    var salary = 10000;
  }
  console.log(salary); //10000 (доступно з області видимості функції)
  console.log(age); //помилка: вік не визначений(через область видимості блоку)
}
userDetails("John");
```

[Back to top ⬆️](#3-javascript)
### 19. Яка причина вибору назви let як ключового слова
`let` - це математичний оператор, який був прийнятий у ранніх мовах програмування, таких як **Scheme** та **Basic**. Його було запозичено з десятків інших мов, які використовують `let` вже як традиційне ключове слово, максимально наближене до `var`.


[Back to top ⬆️](#3-javascript)
### 20. Як перевизначити змінні в switch блоку без помилки
Якщо ви спробуєте перевизначити змінні в "блоці перемикачів", то це призведе до помилок, оскільки існує лише один блок. Наприклад, наведений нижче блок коду викликає синтаксичну помилку, як показано нижче,

```javascript
let counter = 1;
switch (x) {
  case 0
    let name;
    break

  case 1:
    let name; // Синтаксична помилка при перевизначенні.
    break;
}
```

Щоб уникнути цієї помилки, ви можете створити вкладений блок всередині case-речення і створити нове блокове лексичне оточення.

```javascript
let counter = 1;
switch (x) {
  case 0: {
    let name;
    break;
  }
  case 1: {
    let name; // Немає синтаксичної помилки при перевизначенні.
    break;
  }
}
```

[Back to top ⬆️](#3-javascript)
### 21. Що таке Тимчасова мертва зона
Тимчасова мертва зона - це поведінка в JavaScript, яка виникає при оголошенні змінної з ключовими словами let і const, але не з var. В ECMAScript 6 доступ до змінної `let` або `const` до її оголошення (в межах її області видимості) викликає помилку посилання. Проміжок часу, коли це відбувається, між створенням прив'язки змінної та її оголошенням, називається тимчасовою мертвою зоною.

Розглянемо таку поведінку на прикладі:

```javascript
function somemethod() {
  console.log(counter1); // undefined
  console.log(counter2); // ReferenceError
  var counter1 = 1;
  let counter2 = 2;
}
```

[Back to top ⬆️](#3-javascript)
### 22. Що таке Негайно Викликані Функціональні Вирази (IIFE)
IIFE (Immediately Invoked Function Expression) - це функція JavaScript, яка виконується одразу після її визначення. Її підпис буде таким, як показано нижче,

```javascript
(function () {
  // логіка тут
})();
```

Основною причиною використання IIFE є забезпечення конфіденційності даних, оскільки будь-які змінні, оголошені в IIFE, не можуть бути доступні ззовні. Тобто, якщо ви намагаєтесь отримати доступ до змінних за допомогою IIFE, він видасть помилку, як показано нижче,

```javascript
(function () {
  var message = "IIFE";
  console.log(message);
})();
console.log(message); //Ошибка: повідомлення не визначено
```

[Back to top ⬆️](#3-javascript)
### 23. Як декодувати або закодувати URL в JavaScript?
Функція `encodeURI()` використовується для кодування URL-адреси. Ця функція отримує в якості параметра рядок URL-адреси і повертає закодований рядок.
Функція `decodeURI()` використовується для декодування URL-адреси. Ця функція отримує закодований рядок URL як параметр і повертає декодований рядок.

**Примітка:** Якщо ви хочете закодувати такі символи, як `/ ? : @ & = + $ #`, то вам слід використовувати `encodeURIComponent()`.

```javascript
let uri = "employeeDetails?name=john&occupation=manager";
let encoded_uri = encodeURI(uri);
let decoded_uri = decodeURI(encoded_uri);
```

[Back to top ⬆️](#3-javascript)
### 24. Що таке мемоізація
Memoization (Запам'ятовування) - це техніка програмування, яка намагається підвищити продуктивність функції шляхом кешування її попередньо обчислених результатів. Кожного разу, коли викликається функція, що запам'ятовується, її параметри використовуються для індексації кешу. Якщо дані є, то їх можна повернути, не виконуючи всю функцію. В іншому випадку функція виконується, а потім результат додається до кешу.
Розглянемо приклад додавання функції із запам'ятовуванням,

```javascript
const memoizAddition = () => {
  let cache = {};
  return (value) => {
    if (value in cache) {
      console.log("Вибірка з кешу");
      return cache[value]; // Тут cache.value не може бути використано, оскільки назва властивості починається з цифри, яка не є коректним ідентифікатором JavaScript. Отже, доступ до нього можливий лише з використанням квадратних дужок.
    } else {
      console.log("Обчислюємо результат");
      let result = value + 20;
      cache[value] = result;
      return result;
    }
  };
};
// функція, що повертається з memoizAddition
const addition = memoizAddition();
console.log(addition(20)); //виведення: 40 обчислено
console.log(addition(20)); //виведення: 40 кешовано
```

[Back to top ⬆️](#3-javascript)
### 25.Що таке Хойстінг
Hoisting - це механізм JavaScript, за допомогою якого змінні, оголошення функцій і класів переміщуються на початок їхньої області видимості перед виконанням коду. Пам'ятайте, що JavaScript піднімає тільки оголошення, а не ініціалізацію.
Розглянемо простий приклад підйому змінної,

```javascript
console.log(message); //вихід : undefined
var message = "Змінна була піднята";
```

Вищенаведений код для інтерпретатора виглядає так, як показано нижче,

```javascript
var message;
console.log(message);
message = "Змінна була піднята";
```

Таким же чином піднімаються оголошення функцій

```javascript
message("Good morning"); //Доброго ранку

function message(name) {
  console.log(name);
}
```

Цей підйом дозволяє безпечно використовувати функції у коді до їх оголошення.


[Back to top ⬆️](#3-javascript)
### 26. Що таке класи в ES6
В ES6 класи Javascript - це насамперед синтаксичний цукор у порівнянні з існуючим успадкуванням JavaScript на основі прототипів.
Наприклад, успадкування на основі прототипу, записане у вигляді виразу функції, як показано нижче,

```javascript
function Bike(model, color) {
  this.model = model;
  this.color = color;
}

Bike.prototype.getDetails = function () {
  return this.model + " велосипед має" + this.color + " колір";
};
```

В той час як класи ES6 можуть бути визначені як альтернатива

```javascript
class Bike {
  constructor(color, model) {
    this.color = color
    this.model = model;
  }

  getDetails() {
    return this.model + " велосипед має" + this.color + " колір";
  }
}
```

[Back to top ⬆️](#3-javascript)
### 27. Що таке замикання
Закриття - це поєднання функції та лексичного оточення, в якому ця функція була оголошена, тобто це внутрішня функція, яка має доступ до змінних зовнішньої або охоплюючої функції.Закриття має три ланцюжки області видимості

1. Власна область видимості, де змінні визначені між фігурними дужками
2. Змінні зовнішньої функції
3. Глобальні змінні

Розглянемо приклад концепції закриття,

```javascript
function Welcome(name) {
  var greetingInfo = function (message) {
    console.log(message + " " + name);
  };
  return greetingInfo;
}
var myFunction = Welcome("John");
myFunction("Welcome "); //Output: Welcome John
myFunction("Hello Mr."); //output: Hello Mr.John
```

Як видно з вищенаведеного коду, внутрішня функція (тобто greetingInfo) має доступ до змінних в області видимості зовнішньої функції (тобто Welcome) навіть після того, як зовнішня функція повернулася.

[Back to top ⬆️](#3-javascript)
### 28. Що таке модулі
Модулі - це невеликі одиниці незалежного коду, який можна використовувати повторно, а також основа багатьох шаблонів проектування JavaScript. Більшість модулів JavaScript експортують об'єктний літерал, функцію або конструктор

[Back to top ⬆️](#3-javascript)
### 29. Чому вам потрібні модулі
Нижче наведено перелік переваг використання модулів в екосистемі JavaScript

1. Легкість супроводу
2. Можливість повторного використання
3. Простір імен

[Back to top ⬆️](#3-javascript)
### 30. Що таке область видимості в JavaScript
Область видимості - це доступність змінних, функцій та об'єктів у певній частині вашого коду під час виконання. Іншими словами, область видимості визначає видимість змінних та інших ресурсів у певних частинах вашого коду.

[Back to top ⬆️](#3-javascript)
### 31. Що таке сервісний працівник (service worker)    
Сервісний працівник - це, по суті, скрипт (файл JavaScript), який працює у фоновому режимі, окремо від веб-сторінки, і надає функції, які не потребують веб-сторінки або взаємодії з користувачем. Деякі з основних функцій сервісних працівників - це багатий офлайн-досвід (перша розробка веб-додатків в автономному режимі), періодична фонова синхронізація, push-сповіщення, перехоплення та обробка мережевих запитів і програмне керування кешем відповідей.

[Back to top ⬆️](#3-javascript)
### 32. Як ви змінюєте DOM, використовуючи сервісний працівник (service worker)
Сервісний працівник не може отримати доступ до DOM безпосередньо. Але він може взаємодіяти зі сторінками, які він контролює, відповідаючи на повідомлення, надіслані через інтерфейс `postMessage`, і ці сторінки можуть маніпулювати DOM.

[Back to top ⬆️](#3-javascript)
### 33. Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker)
Проблема з сервісним працівником полягає у тому, що він завершується, коли не використовується, і перезапускається, коли він потрібен наступного разу, тому ви не можете покладатися на глобальний стан у обробниках `onfetch` та `onmessage` сервісного працівника. У цьому випадку сервісні працівники матимуть доступ до API IndexedDB для збереження та повторного використання після перезапуску.

[Back to top ⬆️](#3-javascript)
### 34. Що таке IndexedDB
 IndexedDB - це низькорівневий API для зберігання на стороні клієнта великих обсягів структурованих даних, включаючи файли/блоки. Цей API використовує індекси для забезпечення високопродуктивного пошуку в цих даних.

[Back to top ⬆️](#3-javascript)
### 35. Що таке веб-сховище (web storage)
Веб-сховище - це API, який надає механізм, за допомогою якого браузери можуть зберігати пари ключ/значення локально в браузері користувача, в набагато більш інтуїтивно зрозумілий спосіб, ніж використання файлів cookie. Веб-сховище надає два механізми для зберігання даних на клієнті.

1. **Локальне сховище:** Зберігає дані поточного походження без терміну придатності.
2. **Сховище сеансів:** Зберігає дані протягом одного сеансу, і дані втрачаються при закритті вкладки браузера.

[Back to top ⬆️](#3-javascript)
### 36. Що таке пост-повідомлення (post message)
Пост-повідомлення - це метод, який забезпечує перехресний зв'язок між об'єктами Window (наприклад, між сторінкою і спливаючим вікном, яке вона породила, або між сторінкою і вбудованим в неї iframe). Як правило, скриптам на різних сторінках дозволяється доступ один до одного, якщо і тільки якщо сторінки дотримуються політики однакового походження (тобто сторінки використовують один і той самий протокол, номер порту та хост).

[Back to top ⬆️](#3-javascript)
### 37. Що таке кука (cookie)
Файл cookie - це фрагмент даних, який зберігається на вашому комп'ютері для доступу до нього вашим браузером. Файли cookie зберігаються у вигляді пар ключ/значення.
    Наприклад, ви можете створити файл cookie з ім'ям користувача, як показано нижче,

```javascript
document.cookie = "username=John";
```

![Скріншот](images/cookie.png)

[Back to top ⬆️](#3-javascript)
### 38. Чому вам потрібна кука (cookie)
Файли cookie використовуються для запам'ятовування інформації про профіль користувача (наприклад, ім'я користувача). В основному це відбувається в два етапи,

1. Коли користувач відвідує веб-сторінку, профіль користувача може бути збережений у файлі cookie.
2. Наступного разу, коли користувач відвідає сторінку, файл cookie запам'ятає профіль користувача.

[Back to top ⬆️](#3-javascript)
### 39. Які параметри куки (cookie)
Нижче наведено кілька варіантів, доступних для файлів cookie,

1. За замовчуванням, файл cookie видаляється при закритті браузера, але ви можете змінити цю поведінку, встановивши дату закінчення терміну дії (за часом UTC).

```javascript
document.cookie = "username=John; expires=Sat, 10 Jun 2023 10:00:00 UTC";
```

1. За замовчуванням файл cookie належить поточній сторінці. Але ви можете вказати браузеру, до якого шляху належить файл cookie, за допомогою параметра path.

```javascript
document.cookie = "username=John; path=/services";
```


[Back to top ⬆️](#3-javascript)
### 40. Як видаляти куку (cookie)
Ви можете видалити файл cookie, встановивши дату закінчення терміну дії як минулу дату. У цьому випадку вам не потрібно вказувати значення файлу cookie.
    Наприклад, ви можете видалити файл cookie імені користувача на поточній сторінці, як показано нижче.

```javascript
document.cookie = "username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";
```

**Примітка:** Ви повинні вказати шлях до файлу cookie, щоб переконатися, що ви видаляєте правильний файл cookie. Деякі браузери не дозволяють видаляти файли cookie, якщо ви не вкажете параметр шляху.

[Back to top ⬆️](#3-javascript)
### 41. Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage)
Нижче наведено деякі відмінності між файлами cookie, локальним сховищем і сховищем сеансів,

| Функція                               | Cookie | Локальне сховище | Сховище сеансів
|---------------------------------------| ---------------------------------- | ---------------- | ------------------- |
| Доступ на стороні клієнта або сервера | Як на стороні сервера, так і на стороні клієнта | Тільки на стороні клієнта | Тільки на стороні клієнта | Тільки на стороні клієнта
| Термін дії                            | Як налаштовано за допомогою параметра Термін дії | до видалення | до закриття вкладки
|  Підтримка SSL                        | Підтримується | Підтримується | Не підтримується | Не підтримується | Не підтримується
| Максимальний розмір даних             | 4 КБ | 5 МБ | 5 МБ

[Back to top ⬆️](#3-javascript)
### 42. Яка основна різниця між localStorage та sessionStorage
LocalStorage - це те ж саме, що і SessionStorage, але воно зберігає дані, навіть коли браузер закривається і відкривається знову (тобто не має терміну придатності), тоді як у sessionStorage дані очищаються після завершення сеансу роботи зі сторінкою.

[Back to top ⬆️](#3-javascript)
### 43. Як отримати доступ до веб-сховища (web storage)
Об'єкт Window реалізує об'єкти `WindowLocalStorage` та `WindowSessionStorage`, які мають властивості `localStorage` (window.localStorage) та `essionStorage` (window.sessionStorage) відповідно. Ці властивості створюють екземпляр об'єкта Storage, за допомогою якого можна встановлювати, отримувати і видаляти елементи даних для певного домену і типу сховища (сеансового або локального).
    Наприклад, ви можете читати і писати на локальних об'єктах сховища, як показано нижче

```javascript
localStorage.setItem("logo", document.getElementById("logo").value);
localStorage.getItem("logo");
```


[Back to top ⬆️](#3-javascript)
### 44. Які методи доступні для сеансового сховища (session storage)
 У сховищі сесій передбачено методи для читання, запису та очищення даних сесії:

```javascript
// Зберегти дані в sessionStorage
sessionStorage.setItem("key", "value");

// Отримати збережені дані зі сховища sessionStorage
let data = sessionStorage.getItem("key");

// Видалити збережені дані зі сховища sessionStorage
sessionStorage.removeItem("key");

// Видалити усі збережені дані зі сховища sessionStorage
sessionStorage.clear();
```

[Back to top ⬆️](#3-javascript)
### 45. Що таке подія сховища (storage event) та його обробник події (event handler)
StorageEvent - це подія, яка спрацьовує, коли змінюється область зберігання у контексті іншого документа. Тоді як властивість onstorage є обробником подій для обробки подій зберігання.
Синтаксис буде наступним

```javascript
window.onstorage = functionRef;
```

Розглянемо приклад використання обробника подій onstorage, який реєструє ключ сховища та його значення

```javascript
window.onstorage = function (e) {
  console.log(
    "The " +
      e.key +
      " ключ був змінений з " +
      e.oldValue +
      " на " +
      e.newValue +
      "."
  );
};
```

[Back to top ⬆️](#3-javascript)
### 46. Чому вам потрібне веб-сховище (web storage)
Веб-сховище більш безпечне, і великі обсяги даних можна зберігати локально, не впливаючи на продуктивність веб-сайту. Крім того, інформація ніколи не передається на сервер. Тому це більш рекомендований підхід, ніж використання файлів cookie.

[Back to top ⬆️](#3-javascript)
### 47. Як перевірити підтримку веб-сховища браузером (browser support)
Перед використанням веб-сховища необхідно перевірити підтримку браузером localStorage і sessionStorage,

```javascript
if (typeof Storage !== "undefined") {
  // Код для localStorage/sessionStorage.
} else {
  // Вибачте! Веб-сховище не підтримується..
}
```


[Back to top ⬆️](#3-javascript)
### 48. Як перевірити підтримку веб-працівників браузером (browser support)
Перш ніж використовувати веб-працівники, потрібно перевірити підтримку браузером

```javascript
if (typeof Worker !== "undefined") {
  // код підтримки веб-працівників.
} else {
  // Вибачте! Підтримки Web Worker немає..
}
```

[Back to top ⬆️](#3-javascript)
### 49. Надайте приклад веб-працівника (web worker)
Вам потрібно виконати наступні кроки, щоб почати використовувати веб-працівників для прикладу підрахунку

1. Створіть файл веб-програми: Вам потрібно написати скрипт для збільшення значення лічильника. Назвемо його counter.js

```javascript
нехай i = 0;

function timedCount() {
  i = i + 1;
  postMessage(i);
  setTimeout("timedCount()", 500);
}

timedCount();
```

Тут метод postMessage() використовується для відправки повідомлення назад на HTML-сторінку

1. Створіть об'єкт веб-сервера: Ви можете створити об'єкт веб-працівника, перевіривши підтримку браузером. Назвемо цей файл web_worker_example.js

```javascript
if (typeof w == "undefined") {
  w = new Worker("counter.js");
}
```

і ми можемо отримувати повідомлення від web worker

```javascript
w.onmessage = function (event) {
  document.getElementById("message").innerHTML = event.data;
};
```

1. Завершити роботу веб-працівника:
   Веб-засоби продовжуватимуть прослуховувати повідомлення (навіть після завершення роботи зовнішнього скрипту), доки їх не буде завершено. Ви можете використовувати метод terminate() для завершення прослуховування повідомлень.

```javascript
w.terminate();
```

1. Повторне використання веб-працівника: Якщо ви встановите для змінної worker значення undefined, ви можете повторно використовувати код

```javascript
w = undefined;
```

[Back to top ⬆️](#3-javascript)
### 50. Які обмеження веб-працівників на DOM
WebWorker не має доступу до нижченаведених об'єктів javascript, оскільки вони визначені у зовнішніх файлах

1. Об'єкт вікна
2. Об'єкт документа
3. Батьківський об'єкт


[Back to top ⬆️](#3-javascript)
### 51. Що таке обіцянка (promise)

Обіцянка - це об'єкт, який може створити єдине значення колись у майбутньому, або з вирішеним значенням, або з причиною, чому воно не вирішене (наприклад, мережева помилка). Обіцянка перебуватиме в одному з 3 можливих станів: виконана, відхилена або в очікуванні.

Синтаксис створення обіцянки виглядає наступним чином,

```javascript
const promise = new Promise(function (resolve, reject) {
  // опис обіцянки
});
```

Використання обіцянки буде таким, як показано нижче,

```javascript
const promise = new Promise()
  (resolve) => {
    setTimeout(() => {
      resolve("Я - обіцянка!");
    }, 5000);
  },
  (reject) => {}
);

promise.then((value) => console.log(value));
```

Потік дій обіцянки буде таким, як показано нижче,

![Скріншот](images/promises.png)



[Back to top ⬆️](#3-javascript)
### 52. Чому вам потрібна обіцянка (promise)

Обіцянки використовуються для обробки асинхронних операцій. Вони забезпечують альтернативний підхід до зворотних викликів, зменшуючи пекло зворотних викликів і дозволяючи писати чистіший код.


[Back to top ⬆️](#3-javascript)
### 53. Які три стани у обіцянки (promise)

Обіцянки мають три стани:

1. **Очікує:** Це початковий стан обіцянки перед початком операції
2. **Виконано:** Цей стан означає, що вказана операція була завершена.
3. **Відхилено:** Цей стан вказує на те, що операція не була виконана. У цьому випадку буде викинуто значення помилки.


[Back to top ⬆️](#3-javascript)
### 54. Що таке зворотний виклик (callback function)

Функція зворотного виклику - це функція, яка передається в іншу функцію як аргумент. Ця функція викликається всередині зовнішньої функції для виконання певної дії.
Розглянемо простий приклад використання функції зворотного виклику

```javascript
function callbackFunction(name) {
  console.log("Hello " + name);
}

function outerFunction(callback) {
  let name = prompt("Будь ласка, введіть ваше ім'я.");
  callback(name);
}

outerFunction(callbackFunction);
```


[Back to top ⬆️](#3-javascript)
### 55. Чому нам потрібні зворотні виклики (callbacks)

Функції зворотного виклику потрібні тому, що javascript - це мова, керована подіями. Це означає, що замість того, щоб чекати на відповідь, javascript буде продовжувати виконання, слухаючи інші події.
Розглянемо приклад з першою функцією, яка викликає виклик API (імітований за допомогою setTimeout), і наступною функцією, яка записує повідомлення в журнал.

```javascript
function firstFunction() {
  // Імітуємо затримку коду
  setTimeout(function () { // Імітуємо затримку коду.
    console.log("Викликано першу функцію");
  }, 1000);
}
function secondFunction() {
  console.log("Викликано другу функцію");
}
firstFunction();
secondFunction();

Вивести;
// Викликано другу функцію
// Викликана перша функція
```

Як видно з виводу, javascript не дочекався відповіді першої функції і виконав блок коду, що залишився. Таким чином, функція зворотного виклику використовується для того, щоб переконатися, що певний код не виконується, доки інший код не завершить виконання.


[Back to top ⬆️](#3-javascript)
### 56. Що таке "інферно зворотніх викликів" (callback hell)

Пекло зворотного виклику - це антипатерн з декількома вкладеними зворотними викликами, який ускладнює читання та налагодження коду при роботі з асинхронною логікою. Пекло зворотних викликів виглядає наступним чином,

```javascript
async1(function(){
    async2(function(){
        async3(function(){
            async4(function(){
                ....
            });
        });
    });
});
```


[Back to top ⬆️](#3-javascript)
### 57. Що таке події, відправлені з сервера (server-sent events)

Події, що надсилаються сервером (SSE) - це технологія server push, яка дозволяє браузеру отримувати автоматичні оновлення від сервера через HTTP-з'єднання, не вдаючись до опитування. Це односторонній канал зв'язку - події передаються лише від сервера до клієнта. Ця технологія використовується в оновленнях Facebook/Twitter, оновленнях біржових котирувань, новинних стрічках тощо.


[Back to top ⬆️](#3-javascript)
### 58. Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events)

Об’єкт EventSource використовується для отримання сповіщень про події, надісланих сервером. Наприклад, ви можете отримувати повідомлення від сервера, як показано нижче:
```javascript
if (typeof EventSource !== "undefined") {
  var source = new EventSource("sse_generator.js");
  source.onmessage = function (event) {
    document.getElementById("output").innerHTML += event.data + "<br>";
  };
}
```


[Back to top ⬆️](#3-javascript)
### 59. Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events)

Ви можете перевірити підтримку браузером подій, що надсилаються сервером, перед їх використанням, як показано нижче,

```javascript
if (typeof EventSource !== "undefined") {
  // Підтримуються події, відправлені сервером. Давайте напишемо код!
} else {
  // Не підтримуються події, що надсилаються сервером
}
```

[Back to top ⬆️](#3-javascript)
### 60. Які події доступні для подій, відправлених з сервера (server-sent events)

Нижче наведено список подій, доступних для подій, що надсилаються сервером

| Подія | Опис 
|---- | ---- 
| onopen | Використовується, коли відкривається з'єднання з сервером
| onmessage | Ця подія використовується при отриманні повідомлення
| onerror | Відбувається при виникненні помилки



[Back to top ⬆️](#3-javascript)
### 61. Які основні правила обіцянок (promise)

Обіцянки (promises) є важливою частиною асинхронного програмування в JavaScript і допомагають у керуванні асинхронним кодом. Основні правила обіцянок включають наступне:

* **Обіцянка - об'єкт**: Обіцянка - це об'єкт в JavaScript, який представляє асинхронну операцію. Вона може бути в стані "виконується" (pending), "виконано успішно" (fulfilled), або "виконано з помилкою" (rejected).

* **Стан і значення**: Обіцянка має два головних властивості: стан (state) і значення (value). Стан визначає, чи завершилася операція, і як вона завершилася (успішно або з помилкою). Значення містить результат операції або об'єкт помилки.

* **Створення обіцянки**: Обіцянку можна створити за допомогою конструктора `Promise`. Наприклад:

```javascript
const myPromise = new Promise((resolve, reject) => {
 // Виконати асинхронну операцію
 // Якщо успішно - викликати resolve
 // Якщо з помилкою - викликати reject
});
```

* **then() і catch()**: Об'єкт обіцянки має методи `then()` і `catch()`, які використовуються для обробки результату операції або обробки помилок:

    * `then()` викликається, коли обіцянка виконана успішно. Він приймає функцію з результатом операції.
   
    * `catch()` викликається, коли обіцянка виконана з помилкою. Він приймає функцію для обробки помилок.

* **Послідовність then()**: Ви можете викликати метод `then()` послідовно для обробки різних асинхронних операцій в послідовності. Це називається ланцюжком обіцянок.

* **Повернення обіцянок**: Функції, які виконують асинхронні операції, часто повертають обіцянки, щоб інші частини коду могли обробляти результати.

* **Обробка багатьох обіцянок**: Ви можете використовувати метод `Promise.all()` для обробки декількох обіцянок одночасно і очікування їх всіх перед продовженням виконання коду.

* **Обробка першої завершеної обіцянки**: `Promise.race()` дозволяє обробляти результат першої завершеної обіцянки з набору обіцянок.

* **Обіцянки та async/await**: Обіцянки часто використовуються разом з ключовим словом `async` і `await` для структурування асинхронного коду більш читабельно і зручно.

Ці правила допомагають вам працювати з обіцянками в JavaScript ефективно і безпечно при роботі з асинхронним кодом.



[Back to top ⬆️](#3-javascript)
### 62. Що таке зворотній виклик у зворотньому виклику (callback in callback)

Ви можете вкласти один колбек в інший колбек, щоб виконати дії послідовно один за одним. Це називається зворотний виклик у зворотному виклику.

```javascript
loadScript("/script1.js", function (script) {
  console.log("завантажено перший скрипт");

  loadScript("/script2.js", function (script) {
    console.log("завантажено другий скрипт");

    loadScript("/script3.js", функція (скрипт) {
      console.log("завантажено третій скрипт");
      // після завантаження всіх скриптів
    });
  });
});
```

[Back to top ⬆️](#3-javascript)
### 63. Що таке ланцюг обіцянок (promise chaining)

Процес виконання послідовності асинхронних завдань одне за одним з використанням обіцянок називається ланцюжком обіцянок (Promise chaining). Розглянемо приклад ланцюжка обіцянок для обчислення кінцевого результату,

```javascript
new Promise(function (resolve, reject) {
  setTimeout(() => resolve(1), 1000);
})
  .then(function (result) {
    console.log(result); // 1
    return result * 2;
  })
  .then(function (result) {
    console.log(result); // 2
    return result * 3;
  })
  .then(function (result) {
    console.log(result); // 6
    return result * 4;
  });
```

У вищенаведених обробниках результат передається в ланцюжок обробників .then() з наведеним нижче алгоритмом роботи,

1. Початкова обіцянка виконується за 1 секунду,
2. Після цього викликається обробник `.then`, який записує результат(1) і повертає обіцянку зі значенням result \* 2.
3. Після цього значення передається наступному обробнику `.then`, який записує result(2) і повертає обіцянку зі значенням result \* 3.
4. Нарешті, значення передається останньому обробнику `.then`, який записує результат(6) і повертає обіцянку з результатом \* 4.


[Back to top ⬆️](#3-javascript)
### 64. Що таке promise.all

Promise.all - це обіцянка, яка отримує на вхід масив обіцянок (ітерабельний масив) і повертає результат, коли виконано всі обіцянки або відхилено будь-яку з них. Наприклад, синтаксис методу promise.all наведено нижче,

```javascript
Promise.all([Promise1, Promise2, Promise3]) .then(result) => { console.log(result) }) .catch(error => console.log(`Помилка в обіцянках ${error}`))
```

**Примітка:** Пам'ятайте, що порядок обіцянок (виведення результату) зберігається відповідно до порядку введення.


[Back to top ⬆️](#3-javascript)
### 65. Яка мета методу race у обіцянок (promise)

Метод promise.race() повертає екземпляр обіцянки, який першим буде вирішено або відхилено. Розглянемо приклад методу race(), в якому першим обробляється promise2

```javascript
var promise1 = new Promise(function (resolve, reject) {
  setTimeout(resolve, 500, "one");
});
var promise2 = new Promise(function (resolve, reject) {
  setTimeout(resolve, 100, "two");
});

Promise.race([promise1, promise2]).then(function (value) {
  console.log(value); // "two" // Обидві обіцянки вирішаться, але promise2 швидше
});
```


[Back to top ⬆️](#3-javascript)
### 66. Що таке строгий режим у JavaScript (strict mode)

Суворий режим - це нова функція в ECMAScript 5, яка дозволяє помістити програму або функцію в "суворий" робочий контекст. Таким чином, він запобігає виконанню певних дій і генерує більше винятків. Буквальний вираз `"use strict";` вказує браузеру використовувати код javascript в строгому режимі.


[Back to top ⬆️](#3-javascript)
### 67. Чому вам потрібен строгий режим (strict mode)

Суворий режим корисний для написання "безпечного" JavaScript, перетворюючи "поганий синтаксис" на реальні помилки. Наприклад, він усуває випадкове створення глобальної змінної, видаючи помилку, а також видає помилку при присвоюванні властивості, яку не можна записати, властивості, доступної лише для отримання, неіснуючої властивості, неіснуючої змінної або неіснуючого об'єкта.


[Back to top ⬆️](#3-javascript)
### 68. Як ви оголошуєте строгий режим (strict mode)

Строгий режим оголошується додаванням "use strict"; на початку скрипту або функції.
Якщо його оголошено на початку скрипта, він має глобальну область видимості.

```javascript
"use strict";
x = 3.14; // Це призведе до помилки, оскільки x не оголошено
```

а якщо оголосити всередині функції, то вона має локальну область видимості

```javascript
x = 3.14; // Це не викличе помилки.
myFunction();

function myFunction() {
  "use strict";
  y = 3.14; // Це викличе помилку
}
```


[Back to top ⬆️](#3-javascript)
### 69. Яка мета подвійного оклику (!!) (double exclamation)

Виклик double або заперечення(!!) гарантує, що результуючий тип буде логічним. Якщо він був хибним (наприклад, 0, null, undefined і т.д.), він буде хибним, в іншому випадку - істинним.
Наприклад, ви можете перевірити версію IE, використовуючи цей вираз, як показано нижче,

```javascript
let isIE8 = false;
isIE8 = !! navigator.userAgent.match(/MSIE 8.0/);
console.log(isIE8); // повертає true або false
```

Якщо ви не використовуєте цей вираз, то він повертає початкове значення.

```javascript
console.log(navigator.userAgent.match(/MSIE 8.0/)); // повертає масив або null
```

**Примітка:** Вираз !! не є оператором, але це просто двічі оператор !


[Back to top ⬆️](#3-javascript)
### 70. Яка мета оператора delete

Ключове слово delete використовується для видалення властивості та її значення.

```javascript
var user = { name: "John", age: 20 };
delete user.age;

console.log(user); // {name: "John"}
```


[Back to top ⬆️](#3-javascript)
### 71. Який оператор typeof

Ви можете використовувати оператор typeof для визначення типу змінної JavaScript. Він повертає тип змінної або виразу.

```javascript
typeof "John Abraham"; // Повертає "рядок"
typeof (1 + 2); // Повертає "число"
typeof [1, 2, 3] // Повертає "об'єкт", оскільки всі масиви також є об'єктами
```


[Back to top ⬆️](#3-javascript)
### 72. Що таке властивість undefined

Властивість undefined вказує на те, що змінній не присвоєно значення, або вона оголошена, але не ініціалізована взагалі. Тип невизначеного значення також є невизначеним.

```javascript
var user; // Значення не визначено, тип не визначено
console.log(typeof user); //невизначено
```

Будь-яку змінну можна очистити, встановивши їй значення undefined.

```javascript
user = undefined;
```


[Back to top ⬆️](#3-javascript)
### 73. Що таке значення null

Значення null означає навмисну відсутність будь-якого значення об'єкта. Це одне з примітивних значень JavaScript. Тип нульового значення - об'єкт.
Ви можете очистити змінну, встановивши значення null.

```javascript
var user = null;
console.log(typeof user); //об'єкт
```

    
[Back to top ⬆️](#3-javascript)
### 74. Яка різниця між значенням null та undefined

Нижче наведено основні відмінності між null та undefined,

| Null | Undefined                                                                          |
| ----------------------------------------------------------------------------------------------- |------------------------------------------------------------------------------------|
| Це значення присвоєння, яке вказує на те, що змінна вказує на об'єкт, на який немає об'єкта. | Це не значення присвоєння, коли змінна оголошена, але їй ще не присвоєно значення. |
| Тип null - об'єкт | Тип undefined - undefined                                                          |
| Значення null - це примітивне значення, що представляє нульове, порожнє або неіснуюче посилання. Значення undefined - це примітивне значення, що використовується, коли змінній ще не присвоєно значення. | Невизначене значення - це примітивне значення, яке використовується, коли змінній не присвоєно значення. |
| Вказує на відсутність значення для змінної | Вказує на відсутність самої змінної                                                |
| Перетворено в нуль (0) під час виконання примітивних операцій | Перетворено в NaN під час виконання примітивних операцій                           |


[Back to top ⬆️](#3-javascript)
### 75. Що таке функція eval

Функція eval() обчислює JavaScript-код, представлений у вигляді рядка. Рядок може бути виразом JavaScript, змінною, оператором або послідовністю операторів.

```javascript
console.log(eval("1 + 2")); // 3
```


[Back to top ⬆️](#3-javascript)
### 76. Яка різниця між об'єктом window та document

Нижче наведено основні відмінності між вікном і документом,

| Вікно | Документ |
| ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| Це елемент кореневого рівня на будь-якій веб-сторінці | Він є прямим дочірнім елементом віконного об'єкта. Це також відоме як модель об'єктів документа (DOM) |
| За замовчуванням об'єкт window доступний неявно на сторінці | Ви можете отримати до нього доступ за допомогою window.document або document.|
| Він має такі методи, як alert(), confirm(), і такі властивості, як document, location | Він надає такі методи, як getElementById, getElementsByTagName, createElement тощо |


[Back to top ⬆️](#3-javascript)
### 77. Як ви отримуєте доступ до історії у JavaScript

Об'єкт window.history містить історію браузера. Ви можете завантажити попередні та наступні URL-адреси в історії за допомогою методів back() та next().

```javascript
function goBack() {
  window.history.back();
}
function goForward() {
  window.history.forward();
}
```

**Примітка:** Ви також можете отримати доступ до історії без префікса window.

[Back to top ⬆️](#3-javascript)
### 78. Як ви визначаєте, чи включена клавіша Caps Lock, чи ні

Подія `mouseEvent getModifierState()` використовується для повернення булевого значення, яке вказує, чи активовано вказану клавішу-модифікатор, чи ні. Такі модифікатори, як CapsLock, ScrollLock і NumLock активуються при натисканні на них, і деактивуються при повторному натисканні.

Розглянемо на прикладі вхідного елемента, щоб визначити поведінку ввімкненого/вимкненого CapsLock,

```html
<input type="password" onmousedown="enterInput(event)" />

<p id="feedback"></p>

<script>
  function enterInput(e) {
    var flag = e.getModifierState("CapsLock");
    if (flag) {
      document.getElementById("feedback").innerHTML = "CapsLock активовано";
    } else {
      document.getElementById("feedback").innerHTML =
        "CapsLock не активовано";
    }
  }
</script>
```

[Back to top ⬆️](#3-javascript)
### 79. Що таке функція isNaN

Функція isNaN() використовується для визначення того, чи є значення недопустимим числом (Not-a-Number) чи ні. Тобто, ця функція повертає true, якщо значення дорівнює NaN. В іншому випадку повертається false.

```javascript
isNaN("Hello"); //істина
isNaN("100"); //false
```


[Back to top ⬆️](#3-javascript)
### 80. Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined

Нижче наведено основні відмінності між неоголошеними (не визначеними) та невизначеними змінними,

undeclared | undefined |
| ------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| Ці змінні не існують у програмі і не оголошені | Ці змінні оголошені у програмі, але їм не присвоєно жодного значення
| При спробі прочитати значення неоголошеної змінної виникає помилка виконання програми | При спробі прочитати значення невизначеної змінної повертається невизначене значення. |


[Back to top ⬆️](#3-javascript)
### 81. Що таке глобальні змінні

Глобальні змінні - це змінні, які доступні по всьому коду без обмеження області видимості. Для оголошення локальної змінної використовується ключове слово var, але якщо його опустити, то вона стане глобальною змінною

```javascript
msg = "Hello"; // var пропущено, вона стає глобальною змінною
```


[Back to top ⬆️](#3-javascript)
### 82. Які проблеми із глобальними змінними

Проблема глобальних змінних полягає у конфлікті імен змінних локальної та глобальної області видимості. Також складно налагоджувати і тестувати код, який використовує глобальні змінні.


[Back to top ⬆️](#3-javascript)
### 83. Що таке властивість NaN

Властивість NaN - це глобальна властивість, яка представляє значення "Не-число", тобто вказує на те, що значення не є дійсним числом. Дуже рідко використовують NaN у програмі, але його можна використовувати як значення, що повертається, у кількох випадках

```javascript
Math.sqrt(-1);
parseInt("Hello");
```


[Back to top ⬆️](#3-javascript)
### 84. Яка мета функції isFinite

Функція isFinite() використовується для визначення того, чи є число скінченним, законним числом. Вона повертає false, якщо значення +нескінченність, -нескінченність або NaN (Not-a-Number), інакше повертає true.

```javascript
isFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(100); // true
```

[Back to top ⬆️](#3-javascript)
### 85. Що таке потік подій (event flow)

Потік подій - це порядок надходження подій на веб-сторінку. Коли ви клацаєте елемент, вкладений в інші елементи, перш ніж ваш клік досягне місця призначення або цільового елемента, він повинен викликати подію кліку для кожного з його батьківських елементів, починаючи зверху з глобального об'єкта вікна.
Існує два способи проходження події

1. Зверху вниз (перехоплення події)
2. Знизу догори (бульбашковий потік подій)


[Back to top ⬆️](#3-javascript)
### 86. Що таке всплиття подій (event bubbling)

Розповсюдження подій - це тип поширення подій, коли подія спочатку спрацьовує на внутрішньому цільовому елементі, а потім послідовно спрацьовує на предках (батьках) цільового елемента в тій самій ієрархії вкладеності, доки не досягне зовнішнього DOM-елемента.

[Back to top ⬆️](#3-javascript)
### 87. Що таке захоплення подій (event capturing)

Захоплення події - це тип поширення події, коли подія спочатку захоплюється зовнішнім елементом, а потім послідовно спрацьовує на нащадках (дочірніх елементах) цільового елемента в тій самій ієрархії вкладеності, доки не досягне найпотаємнішого елемента DOM.


[Back to top ⬆️](#3-javascript)
### 88. Як ви відправляєте форму за допомогою JavaScript

Ви можете відправити форму за допомогою `document.forms[0].submit()`. Вся інформація з форми надсилається за допомогою обробника події onsubmit

```javascript
function submit() {
  document.forms[0].submit();
}
```


[Back to top ⬆️](#3-javascript)
### 89. Як ви знаходите деталі операційної системи

Об'єкт window.navigator містить інформацію про особливості операційної системи браузера відвідувача. Деякі з властивостей операційної системи доступні у розділі властивостей платформи,

```javascript
console.log(navigator.platform);
```


[Back to top ⬆️](#3-javascript)
### 90. Яка різниця між подіями document load та DOMContentLoaded

Подія `DOMContentLoaded` спрацьовує, коли початковий HTML-документ повністю завантажено і проаналізовано, не чекаючи на завершення завантаження ресурсів (таблиць стилів, зображень і підкадрів). Тоді як подія load спрацьовує, коли завантажується вся сторінка, включаючи всі залежні ресурси (таблиці стилів, зображення).



[Back to top ⬆️](#3-javascript)
### 91. Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами

"Нативні об'єкти" - це об'єкти, які є частиною мови JavaScript, визначені специфікацією ECMAScript. Наприклад, String, Math, RegExp, Object, Function та інші основні об'єкти, визначені в специфікації ECMAScript.
"Хост-об'єкти" - це об'єкти, що надаються браузером або середовищем виконання (Node). Наприклад, вікно, XmlHttpRequest, DOM-вузли тощо вважаються хост-об'єктами.
Користувацькі об'єкти - це об'єкти, визначені в javascript-коді. Наприклад, об'єкти User, створені для інформації про профіль.


[Back to top ⬆️](#3-javascript)
### 92. Які інструменти або техніки використовуються для відлагодження коду JavaScript

Для налагодження JavaScript можна використовувати наступні інструменти або методи

1. Chrome Devtools
2. оператор відладчика
3. Старий добрий оператор console.log


[Back to top ⬆️](#3-javascript)
### 93. Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks)

Нижче наведено перелік переваг та недоліків обіцянок над зворотними викликами,

**Плюси:**

1. Це дозволяє уникнути пекла зворотних дзвінків, які неможливо прочитати
2. Легко писати послідовний асинхронний код з .then()
3. Легко писати паралельний асинхронний код з Promise.all()
4. Вирішує деякі з поширених проблем зворотного виклику (виклик занадто пізно, занадто рано, багато разів і ковтання помилок/винятків)

**Можливі недоліки**

1. Мало складного коду
2. Потрібно завантажувати поліфіл, якщо ES6 не підтримується


[Back to top ⬆️](#3-javascript)
### 94. Яка різниця між атрибутом та властивістю (property)

Атрибути визначаються в HTML-розмітці, тоді як властивості визначаються в DOM. Наприклад, наведений нижче HTML-елемент має 2 атрибути type і value,

```javascript
<input type="text" value="Name:">
```

Ви можете отримати значення атрибута, як показано нижче,

```javascript
const input = document.querySelector("input");
console.log(input.getAttribute("value")); // Доброго ранку
console.log(input.value); // Good morning
```

And after you change the value of the text field to "Good evening", it becomes like

```javascript
console.log(input.getAttribute("value")); // Good evening
console.log(input.value); // Good evening
```


[Back to top ⬆️](#3-javascript)
### 95. Що таке політика однакового походження (same-origin policy)

Політика однакового походження - це політика, яка не дозволяє JavaScript робити запити через межі домену. Походження визначається як комбінація схеми URI, імені хоста і номера порту. Якщо ви ввімкнете цю політику, вона не дозволить шкідливому скрипту на одній сторінці отримати доступ до конфіденційних даних на іншій веб-сторінці за допомогою моделі об'єктів документа (DOM).


[Back to top ⬆️](#3-javascript)
### 96. Яка мета фрази void 0

Void(0) is used to prevent the page from refreshing. This will be helpful to eliminate the unwanted side-effect, because it will return the undefined primitive value. It is commonly used for HTML documents that use href="JavaScript:Void(0);" within an `<a>` element. i.e, when you click a link, the browser loads a new page or refreshes the same page. But this behavior will be prevented using this expression.
For example, the below link notify the message without reloading the page
```javascript
<a href="JavaScript:void(0);" onclick="alert('Well done!')">
  Click Me!
</a>
```

[Back to top ⬆️](#3-javascript)
### 97. Чи є JavaScript компільованою чи інтерпретованою мовою

JavaScript - это интерпретируемый, а не компилируемый язык. Интерпретатор в браузере считывает код JavaScript, интерпретирует каждую строку и запускает его на выполнение. В настоящее время в современных браузерах используется технология Just-In-Time (JIT) компиляции, которая компилирует JavaScript в исполняемый байт-код непосредственно в момент его запуска.

[Back to top ⬆️](#3-javascript)
### 98.	Чи є JavaScript чутливою до регістру мовою

Так, JavaScript - це мова, чутлива до регістру. Ключові слова мови, змінні, назви функцій та об'єктів, а також будь-які інші ідентифікатори завжди повинні вводитися з великої літери.


[Back to top ⬆️](#3-javascript)
### 99. Чи існує якась зв'язок між Java та JavaScript

Ні, це абсолютно різні мови програмування і не мають нічого спільного між собою. Але обидві вони є об'єктно-орієнтованими мовами програмування і, як і багато інших мов, мають схожий синтаксис для основних функцій (if, else, for, switch, break, continue і т.д.).


[Back to top ⬆️](#3-javascript)
### 100. Що таке події (events)

 Події - це "речі", які відбуваються з елементами HTML. Коли JavaScript використовується на HTML-сторінках, він може "реагувати" на ці події. Ось деякі приклади подій HTML,

 1. Веб-сторінка завершила завантаження
 2. Змінено поле введення
 3. Кнопка була натиснута

 Опишемо поведінку події кліку для елемента button,

```javascript
 <!doctype html>
 <html>
  <head>
    <script>
      function greeting() {
        alert('Hello! Good morning');
      }
    </script>
  </head>
  <body>
    <button type="button" onclick="greeting()">Click me</button>
  </body>
 </html>
```
