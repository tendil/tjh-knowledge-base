## **8. Запитання для співбесіди на тему Основні принципи програмування (BPP)**

---


test2


- [1. Статуси відповідей HTTP](#1-http)
- [2. Що таке DRY, KISS, YAGNI](#2-DRY-KISS-YAGNI)
- [3. Які патерни GOF вам відомі? Наведіть приклади їхнього використання](#3-gof)
- [4. PageObject та PageFactory](#4-pageobject-pageFactory)
- [5. Яка ієрархія Collections](#5-collections)
- [6. Різниця між Thread class та Runnable interface](#6-thread-class-runnable-interface)
- [7. Різниця між String, Stringbuffer і Stringbuilder](#7-string-stringbuffer-stringbuilder)
- [8. Різниця між final, finally та finalize](#8-final-finally-finalize)

---

# **Відповіді - 'Основні принципи програмування'**

[Back to top ⬆️](#8-bpp)
### **1. Статуси відповідей HTTP**

Коди згруповано в 5 класів:

1. інформаційні 100 - 199
2. Успішні 200 - 299
3. Перенаправлення 300 - 399
4. Клієнтські помилки 400 - 499
5. Серверні помилки 500 - 599

Детальніше https://developer.mozilla.org/ru/docs/Web/HTTP/Status


[Back to top ⬆️](#8-bpp)
### **2. Що таке DRY, KISS, YAGNI**

**DRY** (Don't Repeat Yourself - Не повторюйся)

Уникайте повторного написання коду, виносячи в абстракції завдання і дані, що часто використовуються. Кожна частина вашого коду або інформації повинна знаходитися в однині в доступному місці. Це один із принципів коду, що читається.

**KISS** (Keep It Simple, Stupid/Keep It Simple and Straightforward - Будь простіше)

Не вигадуйте до завдання складнішого рішення, ніж йому потрібно. Простота коду - понад усе, тому що простий код - найбільш зрозумілий.

**YAGNI** (You Aren't Gonna Need It - Вам це не знадобиться)

Якщо пишете код, будьте впевнені, що він вам знадобиться. Не пишіть код, якщо думаєте, що він стане в нагоді пізніше. Якщо ви займаєтеся рефакторинг методу, класу або файлу, не бійтеся видаляти зайві методи. Навіть якщо раніше вони були корисними – тепер вони не потрібні.


[Back to top ⬆️](#8-bpp)
### **3. Які патерни GOF вам відомі? Наведіть приклади їхнього використання**

*Стратегія (Strategy)* - пропонує визначити сімейство подібних алгоритмів, які часто змінюються чи розширюються, і винести в власні класи, звані стратегіями.
**Приклад**: спосіб побудови маршруту в навігаторі (для авто, пішохода, велосипедиста, громадським транспортом)

*Будівельник (Builder)* - поділяє створення складного об'єкта та ініціалізацію його стану так, що однаковий процес побудови може створити об'єкти з різним станом.
**Приклад**: *позбавлення від зайвих опцій конструктора (Lombok та створення екземплярів класу), StringBuilder*

*Ітератор (Iterator)* - надає спосіб послідовного доступу до елементів множини незалежно від внутрішнього пристрою.
**Приклад**: *foreach*

*Одиночка (Singleton)* - гарантує, що клас має лише один екземпляр і надає глобальний струм доступу до нього.
**Приклад**: *загальний доступ до бази даних із різних частин програми, selenium driver*

*Фабричний метод (Factory Method)* - визначає інтерфейс до створення об'єкта, але дозволяє підкласам вирішувати, який клас інстанціювати. Дозволяє делегувати створення об'єкта підкласів.

*Абстрактна фабрика (Abstarct Factory)* - надає інтерфейс для створення груп пов'язаних чи залежних об'єктів, не вказуючи їх конкретний клас.


[Back to top ⬆️](#8-bpp)
### **4. PageObject та PageFactory**
*Page Object* - патерн при якому кожної сторінки тестованого докладання створюється окремий об'єкт, методи якого інкапсулюють логіку роботи з окремими елементами.  
Дозволяє зменшити кількість коду та спростити його підтримку.  
*Page Factory* - реалізація патерну Factory для створення екземплярів сторінок вбудована в Selenium.


[Back to top ⬆️](#8-bpp)
### **5. Яка ієрархія Collections**

*Інтерфейси*:

* Collection
* List
* Set
* Map
* Sorted Set
* Sorted Map
* Queue

*Класи*:

* Lists:
   * ArrayList
   * LinkedList
   * Vector(deprecated)
* Sets
   * HashSet
   * LinkedHashSet
   * TreeSet
* Maps
   * HashMap
   * TreeMap
   * HashTable (deprecated)
   * LinkedHashMap
* Queue
  * Priority Queue


![IMG](images/difficulty.png)


[Back to top ⬆️](#8-bpp)
### **6. Різниця між Thread class та Runnable interface**

Багатопоточність програми Java організується за допомогою інтерфейсу Runnable і класу Thread, який успадковується від Runnable.  
Перший спосіб більш гнучкий, другий – простіше.  
Коли власний клас повинен успадковуватися від іншого класу (не Thread), доводиться використовувати успадкування від інтерфейсу Runnable, т.к. в Java немає множинного успадкування класів.


[Back to top ⬆️](#8-bpp)
### **7. Різниця між String, Stringbuffer і Stringbuilder**
**String**
Рядки в Java є імунними (не можуть бути змінені). При зміні об'єкта String Java щоразу створюється абсолютно новий об'єкт.
При використанні оператора new для створення в пам'яті купи щоразу буде створюватись новий об'єкт String. При використанні літералу об'єкта ("some string"), якщо такий об'єкт вже існує в купі, новий об'єкт не з'явиться, а змінна змінна буде вказувати на існуючий об'єкт.

**StringBuilder**
Клас StringBuilder є альтернативою класу String, оскільки створює мутабельний (змінюваний) набір символів.
Клас StringBuilder не забезпечує синхронізацію: екземпляри класу StringBuilder не можуть спільно використовувати кілька потоків. Для операцій з рядками в середовищі, що не є багатопотоковим, варто використовувати StringBuilder, тому що він швидше, ніж StringBuffer.

**StringBuffer**
Клас StringBuffer також створює змінний рядковий об'єкт і містить самі методи, як і StringBuilder.
Різниця між ними в тому, що клас StringBuffer є потокобезпечним і синхронізованим: екземпляри класу StringBuffer можуть спільно використовуватися кількома потоками. Для операцій із рядками у багатопотокових середовищах варто використовувати StringBuffer.


[Back to top ⬆️](#8-bpp)
### **8. Різниця між final, finally та finalize**
*final* – модифікатор, який застосовується до змінних, полів, методів та класів. Змінна або поле стає незмінною і потребує ініціалізації. Фінальний метод не можна перевизначити у спадкоємцях. Фінальний клас неспроможна мати спадкоємців взагалі.

*finally* – частина мовної конструкції try-catch-finally.

*finalize* - метод класу Object. Складальник сміття викликає його для об'єктів, на які більше немає посилань і які позначені для збору сміття. Deprecated з Java 9.
