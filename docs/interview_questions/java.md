## **4. Запитання для співбесіди на тему Java**

---

- [1. Типи даних у Java](#1-java)
- [2. Відмінності об'єкта від примітивних типів даних](#2)
- [3. Різниця передачі параметрів за посиланням і за значенням](#3)
- [4. Bytecode](#4-bytecode)
- [5. JVM, JDK, JRE](#5-jvm-jdk-jre)
- [6. Ознаки JavaBean](#6-javabean)
- [7. OutOfMemoryError](#7-outofmemoryerror)
- [8. Стектрейс і як його отримати](#8)
- [9. Всі методи класу object](#9-object)
- [10. Різниця між try-with-resources і try-catch-finally](#10-try-with-resources-try-catch-finally)
- [11. Конструктори та їхні типи](#11)
- [12. Параметризований конструктор](#12)
- [13. Побітові операції](#13)
- [14. Кратка характеристика immutable object і навіщо вони потрібні](#14-immutable-object)
- [15. Вимоги для створення immutable класу](#15-immutable)
- [16. Об'єкти яких стандартних класів immutable в Java](#16-immutable-java)
- [17. Переваги immutable object перед звичайними об'єктами](#17-immutable-object)

- [18. Перелічіть особливості мови програмування Java](#18-java)
- [19. Що ви розумієте під віртуальною машиною Java](#19-java)
- [20. Скільки типів областей пам'яті виділяє JVM?](#20-jvm)
- [21. Що таке JIT-компілятор](#21-jit)
- [22. Що таке платформа](#22)
- [23. Які основні відмінності між платформою Java та іншими платформами](#23-java)
- [24. Що надає Java характеру «напиши один раз і запусти будь-де» ](#24-java)
- [25. Що таке завантажувач класів](#25)
- [26. Чи є порожня назва файлу .java дійсною назвою вихідного файлу](#26-java)
- [27. Чи є ключове слово delete, next, main, exit або null у java](#27-delete-next-main-exit-null-java)
- [28. Що, якщо я напишу static public void замість public static void](#28-static-public-void-public-static-void)
- [29. Яке значення локальних змінних за замовчуванням](#29)
- [30. Які різні специфікатори доступу існують у Java](#30-java)
- [31. Яке призначення статичних методів і змінних](#31)
- [32. Які переваги пакетів у Java](#32-java)
- [33. Що таке об'єктно-орієнтована парадигма](#33)
- [34. Що таке об'єкт](#34)
- [35. Що таке конструктор](#35)
- [36. Скільки типів конструкторів використовується в Java](#36-java)
- [37. Яке призначення конструктора за замовчуванням](#37)
- [38. Чи повертає конструктор якесь значення](#38)
- [39. Чи успадковується конструктор](#39)
- [40. Чи можете ви зробити конструктор остаточним](#40)
- [41. Чи можна перевантажувати конструктори](#41)
- [42. Що ви розумієте під конструктором копіювання в Java](#42-java)
- [43. Які відмінності між конструкторами та методами](#43)
- [44. Що таке статична змінна](#44)
- [45. Що таке статичний метод](#45)
- [46. Які обмеження застосовуються до статичних методів Java](#46-java)
- [47. Чому основний метод є статичним](#47)
- [48. Чи можемо ми перевизначити статичні методи](#48)
- [49. Що таке статичний блок](#49)
- [50. Чи можемо ми виконати програму без методу main()](#50-main)
- [51. Що робити, якщо модифікатор static буде видалено з сигнатури основного методу](#51-static)
- [52. Яка різниця між статичним (класовим) методом і методом екземпляра](#52)
- [53. Чи можемо ми зробити конструктори статичними](#53)
- [54. Чи можемо ми зробити абстрактні методи статичними в Java](#54-java)
- [55. Чи можемо ми оголосити статичні змінні та методи в абстрактному класі](#55)
- [56. Що this за ключове слово в java](#56-this-java)
- [57. Яке основне використання ключового слова this](#57-this)
- [58. Чи можемо ми призначити посилання this змінній](#58-this)
- [59. Як можна здійснити ланцюжок конструкторів за допомогою ключового слова this](#59-this)
- [60. Які переваги передачі this в метод замість самого поточного об’єкта класу](#60-this)
- [61. Що таке спадкування (Inheritance)](#61-inheritance)
- [62. Чому в Java використовується успадкування](#62-java)
- [63. Який клас є суперкласом для всіх класів](#63)
- [64. Чому множинне успадкування не підтримується в Java](#64-java)
- [65. Що таке агрегація (aggregation)](#65-aggregation)
- [66. Що таке композиція (composition)](#66-composition)
- [67. Яка різниця між агрегацією та композицією](#67)
- [68. Чому Java не підтримує покажчики (pointers)](#68-java-pointers)
- [69. Що таке super у java](#69-super-java)
- [70. Як зробити ланцюжок конструкторів за допомогою ключового слова super](#70-super)
- [71. Яке основне використання ключового слова super](#71-super)
- [72. Які відмінності між ключовим словом this і super](#72-this-super)
- [73. Чи можна використовувати this() і super() у конструкторі](#73-this-super)
- [74. Що таке клонування об'єктів](#74)
- [75. Що таке перевантаження методу (method overloading)](#75-method-overloading)
- [76. Чому перевантаження методу неможливе шляхом зміни типу повернення в java](#76-java)
- [77. Чи можемо ми перевантажити методи, зробивши їх статичними](#77)
- [78. Чи можемо ми перевантажити метод main()](#78-main)
- [79. Що таке перевантаження методу з просуванням типу](#79)
- [80. Що таке перевизначення методу](#80)
- [81. Чи можемо ми перевизначити статичний метод](#81)
- [82. Чому ми не можемо перевизначити статичний метод](#82)
- [83. Чи можна перевизначити перевантажений метод](#83)
- [84. Різниця між перевантаженням і перевизначенням методу](#84)
- [85. Чи можемо ми перевизначити приватні методи](#85)
- [86. Чи можемо ми змінити область перевизначеного методу в підкласі](#86)
- [87. Чи можна модифікувати оператор throws методу суперкласу, перевизначивши його в підкласі](#87-throws)
- [88. Чи можна мати віртуальні функції в Java](#88-java)
- [89. Що таке коваріантний тип повернення](#89)
- [90. Що таке кінцева змінна (final variable)](#90-final-variable)
- [91. Що таке кінцевий метод](#91)
- [92. Що таке підсумковий клас](#92)
- [93. Що таке кінцева порожня змінна](#93)
- [94. Чи можемо ми ініціалізувати остаточну порожню змінну](#94)
- [95. Чи можете ви оголосити основний метод як остаточний](#95)
- [96. Чи можемо ми оголосити інтерфейс остаточним](#96)
- [97. Яка різниця між кінцевим методом і абстрактним методом](#97)
- [98. Яка різниця між поліморфізмом під час компіляції та поліморфізмом під час виконання](#98)
- [99. Що таке поліморфізм часу виконання](#99)
- [100. Що таке Runtime Polymorphism](#100-runtime-polymorphism)
- [101. Чи можна досягти поліморфізму часу виконання за допомогою елементів даних](#101)
- [102. Яка різниця між статичним і динамічним зв’язуванням](#102)
- [103. Що таке оператор Java instanceOf](#103-java-instanceOf)
- [104. Що таке абстракція](#104)
- [105. Яка різниця між абстракцією та інкапсуляцією](#105)
- [106. Що таке абстрактний клас](#106)
- [107. Чи може існувати абстрактний метод без абстрактного класу](#107)
- [108. Чи можете ви використовувати як анотацію, так і фінал із методом](#108)
- [109. Чи можливо створити екземпляр абстрактного класу](#109)
- [110. Що таке інтерфейс (java)](#110-java)
- [111. Чи можете ви оголосити метод інтерфейсу статичним](#111)
- [112. Чи може інтерфейс бути остаточним](#112)
- [113. Що таке інтерфейс маркера (marker interface)](#113-marker-interface)
- [114. Чи можемо ми визначити приватні та захищені модифікатори для членів в інтерфейсах](#114)
- [115. Коли посилання на об’єкт може бути приведено до посилання на інтерфейс](#115)
- [116. Як зробити клас тільки для читання в Java](#116-java)
- [117. Як створити клас лише для запису в Java](#117-java)
- [118. Які переваги інкапсуляції в Java](#118-java)
- [119. Що таке пакет](#119)
- [120. Які переваги визначення пакетів у Java](#120-java)
- [121. Як створити пакети в Java](#121-java)
- [122. Як ми можемо отримати доступ до якогось класу в іншому класі в Java](#122-java)
- [123. Чи потрібно мені будь-коли імпортувати пакет java.lang](#123-java-lang)
- [124. Чи можу я імпортувати той самий пакет/клас двічі? Чи завантажить JVM пакет двічі під час виконання?](#124-jvm)
- [125. Що таке статичний імпорт](#125)
- [126. Скільки типів винятків може виникнути в програмі Java](#126-java)
- [127. Що таке обробка винятків](#127)
- [128. Поясніть ієрархію класів Java Exception](#128-java-exception)
- [129. Яка різниця між перевіреним винятком і неперевіреним винятком](#129)
- [130. Який базовий клас для Error і Exception](#130-error-exception)
- [131. Чи обов’язково, щоб після кожного блоку try слідував блок catch](#131-try-catch)
- [132. Що таке finally block](#132-finally-block)
- [133. Чи можна використовувати finally block без catch](#133-finally-block-catch)
- [134. Чи можна повторно кинути виняток](#134)
- [135. Чи може метод перевизначення підкласу оголосити виняток, якщо метод батьківського класу не створює виключення](#135)
- [136. Що таке розповсюдження винятків](#136)
- [137. Що таке пул рядків](#137)
- [138. Що означає immutable стосовно String](#138-immutable-string)
- [139. Чому об’єкти є незмінними в java](#139-java)
- [140. Скількома способами ми можемо створити рядковий об’єкт](#140)
- [141. Чому java використовує концепцію рядкового літералу](#141-java)
- [142. Які відмінності між String і StringBuffer](#142-string-stringbuffer)
- [143. Як ми можемо створити незмінний клас у Java](#143-java)
- [144. Яке призначення методу toString() у Java](#144-tostring-java)
- [145. Чому для зберігання пароля краще використовувати CharArray() перед String](#145-chararray-java)
- [146. Назвіть деякі класи, присутні в пакеті java.util.regex](#146-java-util-regex)
- [147. Чим метасимволи відрізняються від звичайних символів](#147)
- [148. Які переваги внутрішніх класів Java](#148-java)
- [149. Що таке вкладений клас](#149)
- [150. Які недоліки використання внутрішніх класів](#150)
- [151. Які типи внутрішніх класів (нестатичний вкладений клас) використовуються в Java](#151-java)
- [152. Чи є різниця між вкладеними класами та внутрішніми класами](#152)
- [153. Чи можемо ми отримати доступ до нефінальної локальної змінної всередині локального внутрішнього класу](#153)
- [154. Скільки файлів класу створюється під час компіляції OuterClass у наступній програмі](#154-outerclass)
- [155. Що таке анонімні внутрішні класи](#155)
- [156. Що таке вкладений інтерфейс](#156)
- [157. Чи може клас мати інтерфейс (Can a class have an interface)](#157-can-a-class-have-an-interface)
- [158. Чи може інтерфейс мати клас](#158)
- [159. Що таке збірка сміття](#159)
- [160. Що таке gc()](#160-gc)
- [161. Як контролюється вивіз сміття](#161)
- [162. Як об’єкт може бути без посилання](#162)
- [163. Чи можна повторно посилатися на об’єкт без посилання](#163)
- [164. Що це за потік для збору сміття](#164)
- [165. Яка різниця між final, finally і finalize](#165-final-finally-finalize)
- [166. Яке призначення класу Runtime](#166-runtime)
- [167. Як ви будете викликати будь-який зовнішній процес у Java](#167-java)
- [168. Наведіть ієрархію класів InputStream і OutputStream](#168-inputstream-outputstream)
- [169. Що ви розумієте під потоком IO](#169-io)
- [170. Які найвищі класи для всіх потоків](#170)
- [171. Що таке FileInputStream і FileOutputStream](#171)
- [172. Яка мета використання класів BufferedInputStream і BufferedOutputStream](#172-bufferedinputstream-bufferedoutputstream)
- [173. Як налаштувати права доступу до файлу в Java](#173-java)
- [174. Що таке FilterStreams](#174-filterstreams)
- [175. Що таке фільтр введення/виведення (I/O)](#175-i-o)
- [176. Скількома способами в Java можна вводити дані з консолі](#176-java)
- [177. Що таке серіалізація](#177)
- [178. Як можна зробити клас серіалізованим у Java](#178-java)
- [179. Як можна уникнути серіалізації в дочірньому класі, якщо базовий клас реалізує інтерфейс Serializable](#179-serializable)
- [180. Чи можна передати серіалізований об’єкт через мережу](#180)
- [181. Що таке десеріалізація](#181)
- [182. Що таке перехідне ключове слово](#182)
- [183. Яка різниця між інтерфейсом Serializable та Externalizable](#183-serializable-externalizable)
- [184. Дайте короткий опис програмування Java-сокетів](#184-java)
- [185. Що таке Socket](#185-socket)
- [186. Які кроки виконуються, коли два комп’ютери з’єднуються через TCP](#186-tcp)
- [187. Як мені перетворити числову IP-адресу, як-от 192.18.97.39, у ім’я хосту, як-от java.sun.com](#187-ip-192189739-javasuncom)
- [188. Що таке reflection](#188-reflection)
- [189. Яка мета використання класу java.lang.Class](#189-java-lang-class)
- [190. Які існують способи створення екземпляра класу Class](#190-class)
- [191. Яка мета використання javap](#191-javap)
- [192. Чи можете ви отримати доступ до приватного методу поза класом](#192)
- [193. Що таке класи-огортки](#193)
- [194. Що таке автоматичне пакування та розпакування? Коли це відбувається](#194)
- [195. Що є результатом наведеної нижче програми Java](#195)
- [196. Що таке клонування об'єктів](#196)
- [197. Які переваги та недоліки клонування об'єктів](#197)
- [198. Що таке нативний метод](#198)
- [199. Яке призначення ключового слова strictfp](#199-strictfp)
- [200. Яке призначення класу System](#200-system)
- [201. Що спадає на думку, коли хтось згадує поверхневу копію в Java](#201-java)
- [202. Що таке одиночний клас](#202)
- [203. Які контейнери використовують макет рамки як макет за замовчуванням](#203)
- [204. Які контейнери використовують FlowLayout як макет за замовчуванням](#204-flowLayout)
- [205. Що таке незрівнянні компоненти](#205)
- [206. Чи є якась різниця між Scrollbar і ScrollPane](#206-scrollbar-scrollPane)
- [207. Що таке полегшений компонент (lightweight component)](#207-lightweight-component)
- [208. Що таке важкий компонент](#208)
- [209. Що таке аплет](#209)
- [210. Чи можете ви написати клас Java, який можна використовувати як аплет, так і як додаток](#210-java)
- [211. Що таке локаль](#211)
- [212. Як ви будете завантажувати певну мову](#212)
- [213. Що таке JavaBean](#213)
- [214. Яка мета використання компонента Java](#214-java)
- [215. Що таке RMI](#215-rmi)
- [216. Яке призначення заглушки та скелета](#216)
- [217. Які етапи написання програм на основі RMI](#217-rmi)
- [218. Яке використання HTTP-тунелювання в RMI](#218-http-rmi)
- [219. Що таке JRMP](#219-jrmp)
- [220. Чи можуть взаємодіяти програми на основі RMI та CORBA](#220-rmi-corba)
- [221. Як виконати Bubble Sort у Java](#221-bubble-sort-java)
- [222. Як виконати двійковий пошук у Java](#222-java)
- [223. Як виконати сортування виділенням у Java](#223-java)
- [224. Як виконати лінійний пошук у Java](#224-java)
- [225. Як виконати сортування злиттям у Java](#225-java)
- [226. Як виконати швидке сортування в Java](#226-java)

---

# Питання про багатопотоковість і паралелізм

- [227. Що таке багатопотоковість](#227)
- [228. Що таке thread](#228-thread)
- [229. Розрізняйте процес і потік](#229)
- [230. Що ви розумієте під міжпотоковим зв’язком](#230)
- [231. Яке призначення методу wait() у Java](#231-wait-java)
- [232. Чому метод wait() потрібно викликати із синхронізованого блоку](#232-wait)
- [233. Які переваги багатопоточності](#233)
- [234. Які стани життєвого циклу потоку](#234)
- [235. Яка різниця між випереджаючим плануванням і розрізом часу](#235)
- [236. Що таке перемикання контексту](#236)
- [237. Розрізняйте клас Thread та інтерфейс Runnable для створення потоку](#237-thread-runnable)
- [238. Що означає метод join()](#238-join)
- [239. Опишіть призначення та роботу методу sleep()](#239-sleep)
- [240. Яка різниця між методами wait() і sleep()](#240-wait-sleep)
- [241. Чи можна розпочати потік двічі](#241)
- [242. Чи можемо ми викликати метод run() замість start()](#242-run-start)
- [243. А як щодо потоків демона (daemon threads)](#243-daemon-threads)
- [244. Чи можемо ми зробити потік користувача потоком демона, якщо потік запущено](#244)
- [245. Що таке shutdown hook](#245)
- [246. Коли слід переривати потік](#246)
- [247. Що таке синхронізація](#247)
- [248. Яке призначення блоку Synchronized](#248-synchronized)
- [249. Чи можна заблокувати об’єкт Java для виключного використання певним потоком](#249-java)
- [250. Що таке статична синхронізація](#250)
- [251. Яка різниця між notify() і notifyAll()](#251-notify-notifyall)
- [252. Що таке deadlock](#252-deadlock)
- [253. Як виявити стан взаємоблокування? Як цього уникнути](#253)
- [254. Що таке планувальник потоків у java](#254-java)
- [255. Чи кожен потік має свій стек у багатопоточному програмуванні](#255)
- [256. Як досягається безпека потоку](#256)
- [257. Що таке race-condition](#257)
- [258. Що ви розумієте під пулом потоків](#258)
- [259. Які основні компоненти паралельного API](#259)
- [260. Що таке інтерфейс Executor в Concurrency API в Java](#260-executor-concurrency-api-java)


---

# **Відповіді - 'Java'**

[Back to top ⬆️](#4-java)

### **1. Типи даних у Java**
* boolean - true/false
* byte - -128 до 127, 1 байт
* short - (+/-)3276(7/8), 2 байти
* int - (+/-)214748364(7/8), 4 байти
* long - (+/-)9 223 372 036 854 775 80(7/8), 8 байт
* double - з плаваючою крапкою, 8 байт
* float - із плаваючою крапкою, 4 байти
* char - символ у кодуванні UTF-16 (0 до 65535), 2 байти


[Back to top ⬆️](#4-java)
### **2. Відмінності об'єкта від примітивних типів даних**

* примітивні типи виграють у продуктивності та займаній пам'яті


[Back to top ⬆️](#4-java)
### **3. Різниця передачі параметрів за посиланням і за значенням**

*Передача за значенням (by value)* - значення фактичних параметрів копіюються. Метод, що викликається, створює свою копію значень аргументів і потім її використовує. Оскільки робота ведеться з копією, на вихідний параметр це ніяк не впливає.

*Передача за посиланням (by reference)* - параметри передаються як посилання (адреса) на вихідну змінну. Метод, що викликається, не створює свою копію, а посилається на вихідне значення. Отже, зміни, зроблені в методі, що викликається, також будуть відображені у вихідному значенні.

    Java завжди передає параметри за значенням! Однак посилання вказують на один і той самий об'єкт у купі (heap), що призводить до змін параметра навіть у зовнішніх методах.


[Back to top ⬆️](#4-java)
### **4. Bytecode**

Усі ЯП можна умовно розділити на компільовані та інтерпретовані. У Java використовується третій підхід - байт-код. Вихідний код Java перетворюється компілятором на байт-код (а не машинний код). A байт-код Java перетворюється на машинний код за допомогою спеціального інтерпретатора - JVM.


[Back to top ⬆️](#4-java)
### **5. JVM, JDK, JRE**

*JVM (Java Virtual Machine)* - віртуальна машина відповідає за саме виконання коду. Вона працює з байткодом (тим, що міститься всередині файлів із розширенням .class).

*JRE (Java Runtime Environment)* - оточення, необхідне для запуску Java-програм. Включає в себе стандартну бібліотеку. До неї входять, як базові пакети lang, util, так і пакети для роботи з різними форматами, БД, користувацьким інтерфейсом. JVM теж частина JRE.

*JDK (Java Development Kit)* - набір програм для розробки. Включає в себе JRE, завантажувач коду java, компілятор javac, архіватор jar, генератор документації javadoc та інші утиліти, потрібні під час розробки.


[Back to top ⬆️](#4-java)
### **6. Ознаки JavaBean**

1. Усі властивості приватні (для доступу геттери/сеттери)
2. Відкритий конструктор без аргументів
3. Реалізує Serializable


[Back to top ⬆️](#4-java)
### **7. OutOfMemoryError**

Помилка виникає при нестачі фізичної пам'яті для виділення додатку. Через що додатком падає без інформації в логах або потоці виведення про те, де і чому це сталося.


[Back to top ⬆️](#4-java)
### **8. Стектрейс і як його отримати**

Stacktrace (стек викликів) - послідовність викликів функцій у програмі.

```java
StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
    for (StackTraceElement element : stackTraceElements)
    {
       System.out.println(element.getMethodName());
    }
```


[Back to top ⬆️](#4-java)
### **9. Всі методи класу object**

```java
//Вертає строкове представлення об'єкта
public String toString()

//Використовуються для порівняння об'єктів
public native int hashCode()
public boolean equals(Object obj)

//Вертає спеціальний об'єкт, який описує поточний клас
public final native Class getClass()

//Методи для контролю доступу до об'єкта з різних ниток/потоків(threads). Керування синхронізацією ниток
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout)
public final void wait(long timeout, intnanos)
public final void wait()

//Дозволяє "звільнити" рідні не-Java ресурси: закрити файли, потоки тощо.
protected void finalize()

//Дозволяє клонувати об'єкт: створює дублікат об'єкта
protected native Object clone()
```


[Back to top ⬆️](#4-java)
### **10. Різниця між try-with-resources і try-catch-finally**

```try-with-resources``` аналог традиційного та детального блоку ```try-catch-finally```. Реалізація ресурсу повинна виконуватися в ```try()```. Ресурси автоматично закриваються після ```try()```, замість ручного закриття в блоці ```finally``` у ```try-catch-finally```.

```java
try (FileReader fileReader = new FileReader("D:\\\test.txt");) {
...
}
catch (IOException e){
      e.printStackTrace();
}
```


[Back to top ⬆️](#4-java)
### **11. Конструктори та їхні типи**

1. *Конструктор за замовчуванням* - не описаний у класі явно, а створений автоматично компілятором.

2. *Конструктор без аргументів*

```java
public BankAccount() {
    name = "";
    opened = LocalDateTime.now();
    баланс = 0.0d;
}
```


[Back to top ⬆️](#4-java)
### **12. Параметризований конструктор**

```java
public BankAccount(String name, LocalDateTime opened, double balance) {
    this.name = name;
    this.opened = opened;
    this.balance = balance;
}
```
*Конструктор копіювання* - спеціальний конструктор, який застосовується коли необхідно створити копію складного об'єкта, але при цьому ми не хочемо використовувати метод clone().
*Зв'язані конструктори* - один конструктор викликає інший з цього ж класу.


[Back to top ⬆️](#4-java)
### **13. Побітові операції**

*Порозрядні операції* - виконуються над окремими двійковими розрядами або бітами чисел. У цих операціях як операнди можуть виступати тільки цілі числа.

**Логічні операції**:

* & (логічне І / множення) - якщо в обох операндів значення розрядів дорівнює 1, то операція повертає 1, інакше повертається число 0
* | (логічне АБО / додавання) - повертається одиниця, якщо хоча б у одного числа в даному розряді є одиниця
* ^ (логічне виключне АБО / XOR) - Якщо у нас значення поточного розряду в обох чисел різні, то повертається 1, інакше повертається 0
* ~ (логічне заперечення) - інвертує всі розряди числа: якщо значення розряду дорівнює 1, то воно стає 0


[Back to top ⬆️](#4-java)
### **14. Кратка характеристика immutable object і навіщо вони потрібні**

*Іммутабельний (незмінний/immutable) об'єкт* - об'єкт, який після ініціалізації не може змінити свій стан. Тобто якщо в коді є посилання на екземпляр імутабельного класу, то будь-які зміни в ньому призводять до створення нового екземпляра. Імутабельність дає змогу будувати стабільніші програми, і її принципи часто застосовуються у фундаментальних частинах софту.


[Back to top ⬆️](#4-java)
### **15. Вимоги для створення immutable класу**

* Оголошено як final, щоб від нього не можна було успадковувати. Інакше дочірні класи можуть порушити імутабельність.
* Усі поля класу мають бути приватними відповідно до принципів інкапсуляції.
* Повинні бути параметризовані конструктори для коректного створення екземпляра, через які здійснюється первісна ініціалізація полів класу.
* У класі не повинно бути сеттерів, для виключення можливості зміни стану після інстанціювання
* Для полів-колекцій необхідно робити глибокі копії, щоб гарантувати їхню незмінність.


[Back to top ⬆️](#4-java)
### **16. Об'єкти яких стандартних класів immutable в Java**

* String
* Усі класи-обгортки над примітивними типами (Boolean, Integer, Byte, Long...)
* BigInteger і BigDecimal
* Об'єкти класу java.lang.StackTraceElement
* File
* UUID
* Об'єкти класів пакета java.time
* Locale


[Back to top ⬆️](#4-java)
### **17. Переваги immutable object перед звичайними об'єктами**

* Потокобезпека - можна вільно використовувати одночасно з різних ниток.
* Є хорошими ключами в map.
* Відмінно підходять для зберігання констант.
* "Атомарність щодо збою" - якщо immutable об'єкт викине виняток, то він все одно не залишиться в небажаному (зламаному) стані.
* Прості в реалізації та тестуванні
* Не потрібні такі додаткові механізми як конструктор копіювання і реалізація клону.


### **18. Перелічіть особливості мови програмування Java**
[Back to top ⬆️](#4-java)

### **19. Що ви розумієте під віртуальною машиною Java**
[Back to top ⬆️](#4-java)

### **20. Скільки типів областей пам'яті виділяє JVM**
[Back to top ⬆️](#4-java)

### **21. Що таке JIT-компілятор**
[Back to top ⬆️](#4-java)

### **22. Що таке платформа**
[Back to top ⬆️](#4-java)

### **23. Які основні відмінності між платформою Java та іншими платформами**
[Back to top ⬆️](#4-java)

### **24. Що надає Java характеру «напиши один раз і запусти будь-де»**
[Back to top ⬆️](#4-java)

### **25. Що таке завантажувач класів**
[Back to top ⬆️](#4-java)

### **26. Чи є порожня назва файлу .java дійсною назвою вихідного файлу**
[Back to top ⬆️](#4-java)

### **27. Чи є ключове слово delete, next, main, exit або null у java**
[Back to top ⬆️](#4-java)

### **28. Що, якщо я напишу static public void замість public static void**
[Back to top ⬆️](#4-java)

### **29. Яке значення локальних змінних за замовчуванням**
[Back to top ⬆️](#4-java)

### **30. Які різні специфікатори доступу існують у Java**
[Back to top ⬆️](#4-java)

### **31. Яке призначення статичних методів і змінних**
[Back to top ⬆️](#4-java)

### **32. Які переваги пакетів у Java**
[Back to top ⬆️](#4-java)

### **33. Що таке об'єктно-орієнтована парадигма**
[Back to top ⬆️](#4-java)

### **34. Що таке об'єкт**
[Back to top ⬆️](#4-java)


### **35. Що таке конструктор**
[Back to top ⬆️](#4-java)


### **36. Скільки типів конструкторів використовується в Java**
[Back to top ⬆️](#4-java)


### **37. Яке призначення конструктора за замовчуванням**
[Back to top ⬆️](#4-java)


### **38. Чи повертає конструктор якесь значення**
[Back to top ⬆️](#4-java)


### **39. Чи успадковується конструктор**
[Back to top ⬆️](#4-java)


### **40. Чи можете ви зробити конструктор остаточним**
[Back to top ⬆️](#4-java)


### **41. Чи можна перевантажувати конструктори**
[Back to top ⬆️](#4-java)


### **42. Що ви розумієте під конструктором копіювання в Java**
[Back to top ⬆️](#4-java)


### **43. Які відмінності між конструкторами та методами**
[Back to top ⬆️](#4-java)


### **44. Що таке статична змінна**
[Back to top ⬆️](#4-java)


### **45. Що таке статичний метод**
[Back to top ⬆️](#4-java)


### **46. Які обмеження застосовуються до статичних методів Java**
[Back to top ⬆️](#4-java)


### **47. Чому основний метод є статичним**
[Back to top ⬆️](#4-java)


### **48. Чи можемо ми перевизначити статичні методи**
[Back to top ⬆️](#4-java)


### **49. Що таке статичний блок**
[Back to top ⬆️](#4-java)


### **50. Чи можемо ми виконати програму без методу main()**
[Back to top ⬆️](#4-java)


### **51. Що робити, якщо модифікатор static буде видалено з сигнатури основного методу**
[Back to top ⬆️](#4-java)


### **52. Яка різниця між статичним (класовим) методом і методом екземпляра**
[Back to top ⬆️](#4-java)


### **53. Чи можемо ми зробити конструктори статичними**
[Back to top ⬆️](#4-java)


### **54. Чи можемо ми зробити абстрактні методи статичними в Java**
[Back to top ⬆️](#4-java)


### **55. Чи можемо ми оголосити статичні змінні та методи в абстрактному класі**
[Back to top ⬆️](#4-java)


### **56. Що this за ключове слово в java**
[Back to top ⬆️](#4-java)


### **57. Яке основне використання ключового слова this**
[Back to top ⬆️](#4-java)


### **58. Чи можемо ми призначити посилання this змінній**
[Back to top ⬆️](#4-java)


### **59. Як можна здійснити ланцюжок конструкторів за допомогою ключового слова this**
[Back to top ⬆️](#4-java)



### **60. Які переваги передачі this в метод замість самого поточного об’єкта класу**
[Back to top ⬆️](#4-java)


### **61. Що таке спадкування (Inheritance)**
[Back to top ⬆️](#4-java)



### **62. Чому в Java використовується успадкування**
[Back to top ⬆️](#4-java)



### **63. Який клас є суперкласом для всіх класів**
[Back to top ⬆️](#4-java)



### **64. Чому множинне успадкування не підтримується в Java**
[Back to top ⬆️](#4-java)



### **65. Що таке агрегація (aggregation)**
[Back to top ⬆️](#4-java)


### **66. Що таке композиція (composition)**
[Back to top ⬆️](#4-java)


### **67. Яка різниця між агрегацією та композицією**
[Back to top ⬆️](#4-java)



### **68. Чому Java не підтримує покажчики (pointers)**
[Back to top ⬆️](#4-java)



### **69. Що таке super у java**
[Back to top ⬆️](#4-java)


### **70. Як зробити ланцюжок конструкторів за допомогою ключового слова super**
[Back to top ⬆️](#4-java)


### **71. Яке основне використання ключового слова super**
[Back to top ⬆️](#4-java)


### **72. Які відмінності між ключовим словом this і super**
[Back to top ⬆️](#4-java)



### **73. Чи можна використовувати this() і super() у конструкторі**
[Back to top ⬆️](#4-java)



### **74. Що таке клонування об'єктів**
[Back to top ⬆️](#4-java)


### **75. Що таке перевантаження методу (method overloading)**
[Back to top ⬆️](#4-java)


### **76. Чому перевантаження методу неможливе шляхом зміни типу повернення в java**
[Back to top ⬆️](#4-java)


### **77. Чи можемо ми перевантажити методи, зробивши їх статичними**
[Back to top ⬆️](#4-java)



### **78. Чи можемо ми перевантажити метод main()**
[Back to top ⬆️](#4-java)


### **79. Що таке перевантаження методу з просуванням типу**
[Back to top ⬆️](#4-java)


### **80. Що таке перевизначення методу**
[Back to top ⬆️](#4-java)


### **81. Чи можемо ми перевизначити статичний метод**
[Back to top ⬆️](#4-java)

### **82. Чому ми не можемо перевизначити статичний метод**
[Back to top ⬆️](#4-java)


### **83. Чи можна перевизначити перевантажений метод**
[Back to top ⬆️](#4-java)


### **84. Різниця між перевантаженням і перевизначенням методу**
[Back to top ⬆️](#4-java)


### **85. Чи можемо ми перевизначити приватні методи**
[Back to top ⬆️](#4-java)


### **86. Чи можемо ми змінити область перевизначеного методу в підкласі**
[Back to top ⬆️](#4-java)


### **87. Чи можна модифікувати оператор throws методу суперкласу, перевизначивши його в підкласі**
[Back to top ⬆️](#4-java)


### **88. Чи можна мати віртуальні функції в Java**
[Back to top ⬆️](#4-java)


### **89. Що таке коваріантний тип повернення**
[Back to top ⬆️](#4-java)



### **90. Що таке кінцева змінна (final variable)**
[Back to top ⬆️](#4-java)


### **91. Що таке кінцевий метод**
[Back to top ⬆️](#4-java)


### **92. Що таке підсумковий клас**
[Back to top ⬆️](#4-java)


### **93. Що таке кінцева порожня змінна**
[Back to top ⬆️](#4-java)


### **94. Чи можемо ми ініціалізувати остаточну порожню змінну**
[Back to top ⬆️](#4-java)



### **95. Чи можете ви оголосити основний метод як остаточний**
[Back to top ⬆️](#4-java)


### **96. Чи можемо ми оголосити інтерфейс остаточним**
[Back to top ⬆️](#4-java)


### **97. Яка різниця між кінцевим методом і абстрактним методом**
[Back to top ⬆️](#4-java)


### **98. Яка різниця між поліморфізмом під час компіляції та поліморфізмом під час виконання**
[Back to top ⬆️](#4-java)


### **99. Що таке поліморфізм часу виконання**
[Back to top ⬆️](#4-java)



### **100. Що таке Runtime Polymorphism**
[Back to top ⬆️](#4-java)


### **101. Чи можна досягти поліморфізму часу виконання за допомогою елементів даних**
[Back to top ⬆️](#4-java)


### **102. Яка різниця між статичним і динамічним зв’язуванням**
[Back to top ⬆️](#4-java)


### **103. Що таке оператор Java instanceOf**
[Back to top ⬆️](#4-java)


### **104. Що таке абстракція**
[Back to top ⬆️](#4-java)



### **105. Яка різниця між абстракцією та інкапсуляцією**
[Back to top ⬆️](#4-java)


### **106. Що таке абстрактний клас**
[Back to top ⬆️](#4-java)


### **107. Чи може існувати абстрактний метод без абстрактного класу**
[Back to top ⬆️](#4-java)


### **108. Чи можете ви використовувати як анотацію, так і фінал із методом**
[Back to top ⬆️](#4-java)


### **109. Чи можливо створити екземпляр абстрактного класу**
[Back to top ⬆️](#4-java)



### **110. Що таке інтерфейс (java)**
[Back to top ⬆️](#4-java)


### **111. Чи можете ви оголосити метод інтерфейсу статичним**
[Back to top ⬆️](#4-java)


### **112. Чи може інтерфейс бути остаточним**
[Back to top ⬆️](#4-java)


### **113. Що таке інтерфейс маркера (marker interface)**
[Back to top ⬆️](#4-java)


### **114. Чи можемо ми визначити приватні та захищені модифікатори для членів в інтерфейсах**
[Back to top ⬆️](#4-java)


### **115. Коли посилання на об’єкт може бути приведено до посилання на інтерфейс**
[Back to top ⬆️](#4-java)


### **116. Як зробити клас тільки для читання в Java**
[Back to top ⬆️](#4-java)


### **117. Як створити клас лише для запису в Java**
[Back to top ⬆️](#4-java)


### **118. Які переваги інкапсуляції в Java**
[Back to top ⬆️](#4-java)


### **119. Що таке пакет**
[Back to top ⬆️](#4-java)



### **120. Які переваги визначення пакетів у Java**
[Back to top ⬆️](#4-java)


### **121. Як створити пакети в Java**
[Back to top ⬆️](#4-java)


### **122. Як ми можемо отримати доступ до якогось класу в іншому класі в Java**
[Back to top ⬆️](#4-java)


### **123. Чи потрібно мені будь-коли імпортувати пакет java.lang**
[Back to top ⬆️](#4-java)


### **124. Чи можу я імпортувати той самий пакет/клас двічі? Чи завантажить JVM пакет двічі під час виконання?**
[Back to top ⬆️](#4-java)


### **125. Що таке статичний імпорт**
[Back to top ⬆️](#4-java)


### **126. Скільки типів винятків може виникнути в програмі Java**
[Back to top ⬆️](#4-java)


### **127. Що таке обробка винятків**
[Back to top ⬆️](#4-java)


### **128. Поясніть ієрархію класів Java Exception**
[Back to top ⬆️](#4-java)


### **129. Яка різниця між перевіреним винятком і неперевіреним винятком**
[Back to top ⬆️](#4-java)


### **130. Який базовий клас для Error і Exception**
[Back to top ⬆️](#4-java)


### **131. Чи обов’язково, щоб після кожного блоку try слідував блок catch**
[Back to top ⬆️](#4-java)


### **132. Що таке finally block**
[Back to top ⬆️](#4-java)


### **133. Чи можна використовувати finally block без catch**
[Back to top ⬆️](#4-java)


### **134. Чи можна повторно кинути виняток**
[Back to top ⬆️](#4-java)




### **135. Чи може метод перевизначення підкласу оголосити виняток, якщо метод батьківського класу не створює виключення**
[Back to top ⬆️](#4-java)


### **136. Що таке розповсюдження винятків**
[Back to top ⬆️](#4-java)


### **137. Що таке пул рядків**
[Back to top ⬆️](#4-java)


### **138. Що означає immutable стосовно String**
[Back to top ⬆️](#4-java)


### **139. Чому об’єкти є незмінними в java**
[Back to top ⬆️](#4-java)




### **140. Скількома способами ми можемо створити рядковий об’єкт**
[Back to top ⬆️](#4-java)


### **141. Чому java використовує концепцію рядкового літералу**
[Back to top ⬆️](#4-java)


### **142. Які відмінності між String і StringBuffer**
[Back to top ⬆️](#4-java)


### **143. Як ми можемо створити незмінний клас у Java**
[Back to top ⬆️](#4-java)


### **144. Яке призначення методу toString() у Java**
[Back to top ⬆️](#4-java)



### **145. Чому для зберігання пароля краще використовувати CharArray() перед String**
[Back to top ⬆️](#4-java)


### **146. Назвіть деякі класи, присутні в пакеті java.util.regex**
[Back to top ⬆️](#4-java)


### **147. Чим метасимволи відрізняються від звичайних символів**
[Back to top ⬆️](#4-java)


### **148. Які переваги внутрішніх класів Java**
[Back to top ⬆️](#4-java)


### **149. Що таке вкладений клас**
[Back to top ⬆️](#4-java)



### **150. Які недоліки використання внутрішніх класів**
[Back to top ⬆️](#4-java)


### **151. Які типи внутрішніх класів (нестатичний вкладений клас) використовуються в Java**
[Back to top ⬆️](#4-java)


### **152. Чи є різниця між вкладеними класами та внутрішніми класами**
[Back to top ⬆️](#4-java)


### **153. Чи можемо ми отримати доступ до нефінальної локальної змінної всередині локального внутрішнього класу**
[Back to top ⬆️](#4-java)


### **154. Скільки файлів класу створюється під час компіляції OuterClass у наступній програмі**
[Back to top ⬆️](#4-java)


### **155. Що таке анонімні внутрішні класи**
[Back to top ⬆️](#4-java)


### **156. Що таке вкладений інтерфейс**
[Back to top ⬆️](#4-java)


### **157. Чи може клас мати інтерфейс (Can a class have an interface)**
[Back to top ⬆️](#4-java)


### **158. Чи може інтерфейс мати клас**
[Back to top ⬆️](#4-java)


### **159. Що таке збірка сміття**
[Back to top ⬆️](#4-java)


### **160. Що таке gc()**
[Back to top ⬆️](#4-java)


### **161. Як контролюється вивіз сміття**
[Back to top ⬆️](#4-java)


### **162. Як об’єкт може бути без посилання**
[Back to top ⬆️](#4-java)


### **163. Чи можна повторно посилатися на об’єкт без посилання**
[Back to top ⬆️](#4-java)


### **164. Що це за потік для збору сміття**
[Back to top ⬆️](#4-java)


### **165. Яка різниця між final, finally і finalize**
[Back to top ⬆️](#4-java)


### **166. Яке призначення класу Runtime**
[Back to top ⬆️](#4-java)


### **167. Як ви будете викликати будь-який зовнішній процес у Java**
[Back to top ⬆️](#4-java)


### **168. Наведіть ієрархію класів InputStream і OutputStream**
[Back to top ⬆️](#4-java)


### **169. Що ви розумієте під потоком IO**
[Back to top ⬆️](#4-java)


### **170. Які найвищі класи для всіх потоків**
[Back to top ⬆️](#4-java)


### **171. Що таке FileInputStream і FileOutputStream**
[Back to top ⬆️](#4-java)


### **172. Яка мета використання класів BufferedInputStream і BufferedOutputStream**
[Back to top ⬆️](#4-java)


### **173. Як налаштувати права доступу до файлу в Java**
[Back to top ⬆️](#4-java)


### **174. Що таке FilterStreams**
[Back to top ⬆️](#4-java)


### **175. Що таке фільтр введення/виведення (I/O)**
[Back to top ⬆️](#4-java)


### **176. Скількома способами в Java можна вводити дані з консолі**
[Back to top ⬆️](#4-java)


### **177. Що таке серіалізація**
[Back to top ⬆️](#4-java)


### **178. Як можна зробити клас серіалізованим у Java**
[Back to top ⬆️](#4-java)


### **179. Як можна уникнути серіалізації в дочірньому класі, якщо базовий клас реалізує інтерфейс Serializable**
[Back to top ⬆️](#4-java)


### **180. Чи можна передати серіалізований об’єкт через мережу**
[Back to top ⬆️](#4-java)


### **181. Що таке десеріалізація**
[Back to top ⬆️](#4-java)


### **182. Що таке перехідне ключове слово**
[Back to top ⬆️](#4-java)



### **183. Яка різниця між інтерфейсом Serializable та Externalizable**
[Back to top ⬆️](#4-java)


### **184. Дайте короткий опис програмування Java-сокетів**
[Back to top ⬆️](#4-java)


### **185. Що таке Socket**
[Back to top ⬆️](#4-java)


### **186. Які кроки виконуються, коли два комп’ютери з’єднуються через TCP**
[Back to top ⬆️](#4-java)


### **187. Як мені перетворити числову IP-адресу, як-от 192.18.97.39, у ім’я хосту, як-от java.sun.com**
[Back to top ⬆️](#4-java)


### **188. Що таке reflection**
[Back to top ⬆️](#4-java)


### **189. Яка мета використання класу java.lang.Class**
[Back to top ⬆️](#4-java)


### **190. Які існують способи створення екземпляра класу Class**
[Back to top ⬆️](#4-java)


### **191. Яка мета використання javap**
[Back to top ⬆️](#4-java)


### **192. Чи можете ви отримати доступ до приватного методу поза класом**
[Back to top ⬆️](#4-java)


### **193. Що таке класи-огортки**
[Back to top ⬆️](#4-java)


### **194. Що таке автоматичне пакування та розпакування? Коли це відбувається**
[Back to top ⬆️](#4-java)


### **195. Що є результатом наведеної нижче програми Java**
[Back to top ⬆️](#4-java)


### **196. Що таке клонування об'єктів**
[Back to top ⬆️](#4-java)


### **197. Які переваги та недоліки клонування об'єктів**
[Back to top ⬆️](#4-java)


### **198. Що таке нативний метод**
[Back to top ⬆️](#4-java)


### **199. Яке призначення ключового слова strictfp**
[Back to top ⬆️](#4-java)


### **200. Яке призначення класу System**
[Back to top ⬆️](#4-java)


### **201. Що спадає на думку, коли хтось згадує поверхневу копію в Java**
[Back to top ⬆️](#4-java)


### **202. Що таке одиночний клас**
[Back to top ⬆️](#4-java)


### **203. Які контейнери використовують макет рамки як макет за замовчуванням**
[Back to top ⬆️](#4-java)


### **204. Які контейнери використовують FlowLayout як макет за замовчуванням**
[Back to top ⬆️](#4-java)


### **205. Що таке незрівнянні компоненти**
[Back to top ⬆️](#4-java)


### **206. Чи є якась різниця між Scrollbar і ScrollPane**
[Back to top ⬆️](#4-java)


### **207. Що таке полегшений компонент (lightweight component)**
[Back to top ⬆️](#4-java)


### **208. Що таке важкий компонент**
[Back to top ⬆️](#4-java)


### **209. Що таке аплет**
[Back to top ⬆️](#4-java)


### **210. Чи можете ви написати клас Java, який можна використовувати як аплет, так і як додаток**
[Back to top ⬆️](#4-java)


### **211. Що таке локаль**
[Back to top ⬆️](#4-java)


### **212. Як ви будете завантажувати певну мову**
[Back to top ⬆️](#4-java)


### **213. Що таке JavaBean**
[Back to top ⬆️](#4-java)


### **214. Яка мета використання компонента Java**
[Back to top ⬆️](#4-java)


### **215. Що таке RMI**
[Back to top ⬆️](#4-java)


### **216. Яке призначення заглушки та скелета**
[Back to top ⬆️](#4-java)


### **217. Які етапи написання програм на основі RMI**
[Back to top ⬆️](#4-java)


### **218. Яке використання HTTP-тунелювання в RMI**
[Back to top ⬆️](#4-java)


### **219. Що таке JRMP**
[Back to top ⬆️](#4-java)


### **220. Чи можуть взаємодіяти програми на основі RMI та CORBA**
[Back to top ⬆️](#4-java)


### **221. Як виконати Bubble Sort у Java**
[Back to top ⬆️](#4-java)


### **222. Як виконати двійковий пошук у Java**
[Back to top ⬆️](#4-java)


### **223. Як виконати сортування виділенням у Java**
[Back to top ⬆️](#4-java)


### **224. Як виконати лінійний пошук у Java**
[Back to top ⬆️](#4-java)


### **225. Як виконати сортування злиттям у Java**
[Back to top ⬆️](#4-java)


### **226. Як виконати швидке сортування в Java**
[Back to top ⬆️](#4-java)


### **227. Що таке багатопотоковість**
[Back to top ⬆️](#4-java)


### **228. Що таке thread**
[Back to top ⬆️](#4-java)


### **229. Розрізняйте процес і потік**
[Back to top ⬆️](#4-java)


### **230. Що ви розумієте під міжпотоковим зв’язком**
[Back to top ⬆️](#4-java)



### **231. Яке призначення методу wait() у Java**
[Back to top ⬆️](#4-java)


### **232. Чому метод wait() потрібно викликати із синхронізованого блоку**
[Back to top ⬆️](#4-java)


### **233. Які переваги багатопоточності**
[Back to top ⬆️](#4-java)


### **234. Які стани життєвого циклу потоку**
[Back to top ⬆️](#4-java)


### **235. Яка різниця між випереджаючим плануванням і розрізом часу**
[Back to top ⬆️](#4-java)


### **236. Що таке перемикання контексту**
[Back to top ⬆️](#4-java)


### **237. Розрізняйте клас Thread та інтерфейс Runnable для створення потоку**
[Back to top ⬆️](#4-java)


### **238. Що означає метод join()**
[Back to top ⬆️](#4-java)


### **239. Опишіть призначення та роботу методу sleep()**
[Back to top ⬆️](#4-java)


### **240. Яка різниця між методами wait() і sleep()**
[Back to top ⬆️](#4-java)


### **241. Чи можна розпочати потік двічі**
[Back to top ⬆️](#4-java)


### **242. Чи можемо ми викликати метод run() замість start()**
[Back to top ⬆️](#4-java)


### **243. А як щодо потоків демона (daemon threads)**
[Back to top ⬆️](#4-java)


### **244. Чи можемо ми зробити потік користувача потоком демона, якщо потік запущено**
[Back to top ⬆️](#4-java)


### **245. Що таке shutdown hook**
[Back to top ⬆️](#4-java)


### **246. Коли слід переривати потік**
[Back to top ⬆️](#4-java)


### **247. Що таке синхронізація**
[Back to top ⬆️](#4-java)


### **248. Яке призначення блоку Synchronized**
[Back to top ⬆️](#4-java)


### **249. Чи можна заблокувати об’єкт Java для виключного використання певним потоком**
[Back to top ⬆️](#4-java)



### **250. Що таке статична синхронізація**
[Back to top ⬆️](#4-java)



### **251. Яка різниця між notify() і notifyAll()**
[Back to top ⬆️](#4-java)


### **252. Що таке deadlock**
[Back to top ⬆️](#4-java)


### **253. Як виявити стан взаємоблокування? Як цього уникнути**
[Back to top ⬆️](#4-java)


### **254. Що таке планувальник потоків у java**
[Back to top ⬆️](#4-java)


### **255. Чи кожен потік має свій стек у багатопоточному програмуванні**
[Back to top ⬆️](#4-java)


### **256. Як досягається безпека потоку**
[Back to top ⬆️](#4-java)


### **257. Що таке race-condition**
[Back to top ⬆️](#4-java)


### **258. Що ви розумієте під пулом потоків**
[Back to top ⬆️](#4-java)


### **259. Які основні компоненти паралельного API**
[Back to top ⬆️](#4-java)


### **260. Що таке інтерфейс Executor в Concurrency API в Java**
[Back to top ⬆️](#4-java)


